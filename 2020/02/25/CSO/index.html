<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="笔记">
<meta name="keywords" content="计算机系统结构">
<meta property="og:type" content="article">
<meta property="og:title" content="endacsd">
<meta property="og:url" content="http://endacsd.github.io/2020/02/25/CSO/index.html">
<meta property="og:site_name" content="endacsd">
<meta property="og:description" content="笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200223195955756.png">
<meta property="og:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200224110017184.png">
<meta property="og:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200224110048138.png">
<meta property="og:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200224110116017.png">
<meta property="og:image" content="https://mooc1-2.chaoxing.com/images/Rtiao.png">
<meta property="og:image" content="c:/hexo/Blog/pictrue/COS1.png">
<meta property="og:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200417004847846.png">
<meta property="og:image" content="https://p.ananas.chaoxing.com/star3/190_190c/548e30464963ff55a1ebcf90a4374769.jpg">
<meta property="og:image" content="https://p.ananas.chaoxing.com/star3/origin/049bff7024af510580dff9b7f3bc8a4d.png">
<meta property="og:image" content="https://p.ananas.chaoxing.com/star3/origin/6252809c23aab9be73671204dcf31880.png">
<meta property="og:updated_time" content="2020-04-23T14:23:51.845Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="endacsd">
<meta name="twitter:description" content="笔记">
<meta name="twitter:image" content="c:/Users/EndA/AppData/Roaming/Typora/typora-user-images/image-20200223195955756.png">
  <link rel="canonical" href="http://endacsd.github.io/2020/02/25/CSO/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title> | endacsd</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">endacsd</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-playlist">
      
    

    <a href="/playlist/" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i> <br>歌单</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/endacsd" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://endacsd.github.io/2020/02/25/CSO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="endacsd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="endacsd">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-25 15:54:31" itemprop="dateCreated datePublished" datetime="2020-02-25T15:54:31+08:00">2020-02-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 22:23:51" itemprop="dateModified" datetime="2020-04-23T22:23:51+08:00">2020-04-23</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>笔记</p>
<a id="more"></a>
<meta name="referrer" content="no-referrer">





<h3 id="计算机系统结构的基本概念"><a href="#计算机系统结构的基本概念" class="headerlink" title="计算机系统结构的基本概念"></a>计算机系统结构的基本概念</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>系统结构的转折</p>
<p>从单纯依靠指令级并行转向开发线程级并行和数据级并行</p>
<p>计算机系统结构在计算机的发展种有着极其重要的作用</p>
<h4 id="计算机系统结构的概念"><a href="#计算机系统结构的概念" class="headerlink" title="计算机系统结构的概念"></a>计算机系统结构的概念</h4><h5 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h5><p>计算机系统=硬件/固件 + 软件</p>
<p>计算机语言从低级向高级发展</p>
<p>高一级语言的语句相对于低一级语言来说功能更强更便于应用，但以低级语言为基础</p>
<p>从计算机语言的角度，把计算机系统按功能划分成 多级层次结构</p>
<p>每一层以一种语言为特征</p>
<p>虚拟机 由软件实现的机器</p>
<p>语言实现的两种基本技术</p>
<p>翻译 先把N+1 级程序全部转换成N级程序后，再去执行新产生的N级程序，再执行过程中N+1级程序不再被访问</p>
<p>解释 每当一条N+1 级指令被译码后，就直接执行一串等效的N级指令，然后再去取下一条N+1级的指令，以此重复进行</p>
<p>解释执行比编译后执行所花的时间多，但占用的存储空间较少</p>
<h5 id="计算机系统结构的定义"><a href="#计算机系统结构的定义" class="headerlink" title="计算机系统结构的定义"></a>计算机系统结构的定义</h5><p>1 计算机系统结构的经典定义</p>
<p>2程序员所看到的计算机属性，即概念性结构与功能特性</p>
<p>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性</p>
<p>3 透明性</p>
<p>在计算机技术中，把这种本来存在的事物或属性，但从某种角度又好像不存在的概念称为透明性</p>
<p>4 Amdahl 提出的系统结构</p>
<p>传统机器语言机程序员所看到的计算机属性</p>
<p>5 广义的系统结构定义 指令集结构，组成，硬件</p>
<p>6 对于通用寄存器型寄存器机器来说，这些属性主要是指</p>
<ul>
<li>指令系统</li>
</ul>
<p>包括机器指令的操作类型和格式，指令间的排序和控制机构等</p>
<ul>
<li>数据表示</li>
</ul>
<p>硬件能直接识别和处理的数据类型</p>
<ul>
<li>寻址规则</li>
<li>包括最小寻址单元，寻址方式及其表示</li>
</ul>
<ul>
<li>寄存器定义</li>
<li>中断系统</li>
<li>机器工作状态的定义和切换</li>
<li>存储系统</li>
<li>信息保护</li>
<li>I/O结构</li>
</ul>
<p>计算机系统结构概念的实质</p>
<p>确定计算机系统中软硬件的界面，界面之上时软件实现的功能，界面之下时硬件和固件实现的功能</p>
<h5 id="计算机组成和计算机实现"><a href="#计算机组成和计算机实现" class="headerlink" title="计算机组成和计算机实现"></a>计算机组成和计算机实现</h5><p>1 计算机系统结构 计算机系统的软，硬件的界面</p>
<p>即机器语言程序员所看到的传统机器级所具有的属性</p>
<p>2计算机组成 计算机系统结构的逻辑实现</p>
<p>包含物理机器级中的数据流和控制流的组成以及逻辑设计等</p>
<p>着眼于： 物理机器级内各事件的排序方式与控制方式，各部件的功能以及各部件之间的联系</p>
<p>3计算机实现 计算机组成的物理实现</p>
<p>包括部件的物理结构，器件的集成度和速度，模块，插件，底板的划分与连接，信号传输，电源，冷却及整机装配技术等</p>
<p>着眼于： 器件技术(主导作用)，微组装技术</p>
<p>一种体系结构可以有多种组成</p>
<p>一种组成可以有多种物理实现</p>
<p>4 系列机</p>
<h4 id="计算机系统结构的分类"><a href="#计算机系统结构的分类" class="headerlink" title="计算机系统结构的分类"></a>计算机系统结构的分类</h4><p>常见的计算机系统接哦古分类方法有两种</p>
<p>Flynn分类法，冯氏分类法</p>
<p>1 冯氏分类法</p>
<p>用系统的最大并行度对计算机进行分类</p>
<p>最大并行度 计算机系统在单位时间内能够处理的最大的二进制位数</p>
<p>用平面直角坐标系中的一个点表示一个计算机系统，其横坐标表示字宽（n位），纵坐标表示一次能同时处理的字数（m字)。$m \times n$ 表示其最大并行度</p>
<p>2 Flynn 分类法</p>
<p>按照指令流和数据流的多倍型进行分类</p>
<p>指令流 计算机执行的指令序列</p>
<p>数据流 由指令流调用的数据序列</p>
<p>多倍性 在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目</p>
<p>Flynn 分类法把计算机系统的结构分为4类</p>
<p>单指令流单数据流（SISD)</p>
<p>单指令流多数据流（SIMD)</p>
<p>多指令流单数据流（MISD)</p>
<p>多指令流多数据流（MIMD)</p>
<p>IS 指令流, DS 数据流 ， CS 控制流</p>
<p>CU 控制部件，PU 处理部件， MM,SM 存储器</p>
<p><img src="C:\Users\EndA\AppData\Roaming\Typora\typora-user-images\image-20200223195955756.png" alt="image-20200223195955756"></p>
<h4 id="定量分析技术"><a href="#定量分析技术" class="headerlink" title="定量分析技术"></a>定量分析技术</h4><p>1 计算机系统设计的定量原理</p>
<p>4 个定量原理</p>
<p>1 以经常性事件为重点</p>
<p>对经常发生的情况采用优化方法的原则进行选择，以得到更多的总体上的改进</p>
<p>优化是指分配更多的资源，达到更高的性能或者分配更多的资源等</p>
<p>2 Amdahl 定律</p>
<p>加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统总执行时间的百分比</p>
<script type="math/tex; mode=display">
加速比=\frac{系统性能_{改进前}}{系统性能_{改进后}}=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}</script><p>加速比依赖于两个因素</p>
<p>可改进比例 在改进前的系统中，可改进部分的执行在总的执行时间中所占的比例</p>
<p>它总是小于等于1</p>
<p>部件加速比 可改进部分改进以后性能提升的被数</p>
<p>它是改进前所需的执行时间与改进后执行时间的比</p>
<p>一般情况部件加速比是大于1的</p>
<script type="math/tex; mode=display">
总执行时间_{改进后}=不可改进部分得执行时间+可改进部分改进后得执行时间

\\
总执行时间_{改进后}=(1-可改进比例)\times 总执行时间_{改进前}+
\frac{可改进比例\times 总执行时间_{改进前}}{部件加速比}
\\
=[(1-可改进比例)\frac{可改进比例}{部件加速比}]\times 总执行时间_{改进前}</script><p>系统加速比为改进前与改进后总执行时间之比</p>
<script type="math/tex; mode=display">
加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}
\\
=\frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}}</script><p>Amdahl 定律 一种性能改进的递减规则</p>
<p>如果仅仅对计算任务中的一部分做性能改进，则改进得越多，所得到得总性能得提升就越有限</p>
<p>如果只针对整个任务得一部分进行改进和优化，那么所获得得加速比不超过$\frac{1}{1-可改进比例}$</p>
<p>3 CPU 性能公式</p>
<p>执行一个程序所需得CPU时间</p>
<p>CPU时间=执行程序所需要得时钟周期数$\times$ 时钟周期时间</p>
<p>每条指令执行得平均时钟周期数CPI</p>
<p>CPI = 执行程序所需要得时钟周期数/IC</p>
<p>IC 所执行得指令条数</p>
<p>程序执行的CPU时间可以写成</p>
<p>CPU时间=IC$\times$CPI$\times$时钟周期数</p>
<p>CPU的性能取决于三个参数</p>
<p>时钟周期时间 取决硬件实现技术和计算机组成</p>
<p>CPI 取决于计算机组成和指令集结构</p>
<p>IC  取决于指令集结构和编译技术</p>
<p>局部性原理</p>
<p>时间局部性</p>
<p>空间局部性</p>
<p>部分题目</p>
<p><img src="C:\Users\EndA\AppData\Roaming\Typora\typora-user-images\image-20200224110017184.png" alt="image-20200224110017184"></p>
<script type="math/tex; mode=display">
\frac{1}{\frac{0.4}{20}+0.6}=\frac{1}{0.62}=1.61</script><p><img src="C:\Users\EndA\AppData\Roaming\Typora\typora-user-images\image-20200224110048138.png" alt="image-20200224110048138"></p>
<script type="math/tex; mode=display">
\frac{1}{\frac{x}{20}+1-x}=5
\\
1=\frac{x}{4}+5-5x
\\
\frac{19x}{4}=4\\
x=0.842</script><p><img src="C:\Users\EndA\AppData\Roaming\Typora\typora-user-images\image-20200224110116017.png" alt="image-20200224110116017"></p>
<h4 id="计算机系统结构的发展"><a href="#计算机系统结构的发展" class="headerlink" title="计算机系统结构的发展"></a>计算机系统结构的发展</h4><h5 id="冯-cdot-诺伊曼结构"><a href="#冯-cdot-诺伊曼结构" class="headerlink" title="冯 $\cdot$诺伊曼结构"></a>冯 $\cdot$诺伊曼结构</h5><p>最早的存储程序式计算机于1946年提出来的，它由运算器，控制器，存储器，输入设备，输出设备5部分构成，通常称之为冯$\cdot$ 诺伊曼结构计算机</p>
<p>存储程序原理的基本点时指令驱动，程序预先放在计算机存储器中。</p>
<p>主要特点</p>
<ul>
<li>计算机以运算器为中心，输入/输出设备与存储器之间的数据传送都经过运算器；存储器，输入/输出设备的操作以及它们之间的联系都由控制器集中控制。</li>
<li>在存储器中，指令和数据同等对待，指令和数据一样可以进行运算</li>
<li>存储器时按地址访问，按顺序先性编址的一维结构，每个单元的位数时固定的</li>
<li>指令的执行是顺序的，分支由转移指令实现</li>
<li>指令由操作码和地址码组成.操作码指明本指令的操作类型，地址码指明操作数地址和存放运算结构的地址。操作数的类型由操作码决定，操作数本身不能判定是何种数据类型</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
<p>后来进行了改进</p>
<p>(1) 对输入/输出方式的改进</p>
<p>冯诺伊曼结构以运算器为中心，所有部件的操作都由控制器集中控制。这使输入/输出云操作运算只能串行进行。人们提供了多种I/O</p>
<p>实际上是把I/O的管理工作从CPU分离出来，给新设置的硬件完成，</p>
<p>出现DMA(Direct Memory Access,直接存储器访问)，这是在外设与存储器之间建立数据通路，使它们可以直接传送数据，而不必经过运算器，为了实现这种方式，需要在主存和外设之间增加DMA控制器。</p>
<p>当要进行I/O操作时，CPU将DMA控制器中的寄存器设置号初始参数后，仍可以继续执行后续指令，而外设与主存的信息交换则由DMA控制进行。当DMA完成所指定的一批数据的传送后，才向CPU发结束信号，使CPU进行一些事后处理工作</p>
<p>采用DMA方式，每传送完一批数据就要中断一次，如果进一步使该部件能够控制完成I/O的大部分工作，从而使CPU进一步摆脱用于管理和控制I/O操作和传送信息的所有功能都从CPU那里接管过来，独立出去，I/O处理机方式由管道方式和外围处理机方式两种</p>
<p>(2)采用并行处理技术</p>
<p>(3)存储器组织结构的发展</p>
<p>按内容访问的相联存储器(Content Addressed Memory,CAM) 把查找，比较的操作交由存储器硬件完成。</p>
<p>采用了cache</p>
<p>(4)指令集的发展</p>
<p>越来越多的功能可以由硬件实现</p>
<p>RISC和CISC</p>
<h4 id="软件对系统结构的影响"><a href="#软件对系统结构的影响" class="headerlink" title="软件对系统结构的影响"></a>软件对系统结构的影响</h4><p>可移植性是指 一个软件不经过修改或者只需要少量修改就可以由一台计算机移植到另一台计算机上运行。差别只是执行时间的不同。在这种情况下，称这两台计算机时软件兼容的。实现可移植性性的常用方法3种：采用系列机，模拟与仿真，同意高级语言</p>
<ol>
<li>系列机</li>
</ol>
<p>软件兼容有4种，向下兼容，向下兼容，向下兼容，向下兼容</p>
<p>2.模拟与仿真</p>
<p>模拟 指用软件的方法在一台现有的计算机(宿主机)实现另外一台计算机(虚拟机)的指令集，通常使用解释的方法来实现，虚拟机的每一条指令都用宿主机的一段程序进行解释执行</p>
<p>仿真 由微程序去解释实现另一台计算机的指令集，还需要仿真其存储系统,I/O系统和控制台操作</p>
<p>模拟程序存放在主存中，仿真微程序则是存放在控制存储器中，</p>
<p>仿真快，但是只能用于系统结构差距不大计算机</p>
<p>3.统一高级语言</p>
<h4 id="器件发展对系统结构的影响"><a href="#器件发展对系统结构的影响" class="headerlink" title="器件发展对系统结构的影响"></a>器件发展对系统结构的影响</h4><p>器件技术，特别时超大规模集成电路(Very Large Scale Integration,VLSI)技术的发展速度很快</p>
<p>5代计算机的典型特征</p>
<p>图片</p>
<h5 id="应用对系统结构的影响"><a href="#应用对系统结构的影响" class="headerlink" title="应用对系统结构的影响"></a>应用对系统结构的影响</h5><h4 id="计算机系统结构中并行性的发展"><a href="#计算机系统结构中并行性的发展" class="headerlink" title="计算机系统结构中并行性的发展"></a>计算机系统结构中并行性的发展</h4><h5 id="并行性的概念"><a href="#并行性的概念" class="headerlink" title="并行性的概念"></a>并行性的概念</h5><p>所谓并行性(parallelism)，是指计算机系统在同一时刻或同一时间间隔内进行多种运算或操作，只要在时间上互相重叠就存在并行性，它包括同时性与并发性两种含义</p>
<p>同时性(simultaneity)是指两个或两个以上的事件在同一时刻发生。并发性(concurrency)是指两个或两个以上的事件在同一时间间隔内发生</p>
<p>并行性等级从高到低可以分为一下几个等级</p>
<p>按处理数据来看</p>
<p>(1) 字串位串 每次只对一个字的一位进行处理。不存在并行</p>
<p>(2) 字串位并 同时对一个字的全部位进行处理，不懂字之间是穿行的，已经开始出现并行性</p>
<p>(3) 字并位串 同时许多字的同一位(位片)进行处理，这种方式具有较高的并行性</p>
<p>(4) 全并行 同时对许多字的全部位或者部分位进行处理，这是最高一级的并行</p>
<p>从执行程序的角度来看</p>
<p>(1) 指令内部并行，单指令中各微操作之间的并行</p>
<p>(2)指令级并行(Instruction Level Parallelism,ILP)： 并行执行两条或两条以上的指令</p>
<p>(3) 线程级并行(TLP): 并行执行两个或两个以上的线程，通常是以一个进程内派生多个线程为调度单位</p>
<p>(4) 任务级或过程级并行，并行执行两个或连个以上的过程或任务，以子系统或进程为调度单元</p>
<p>(5) 作业或程序级并行：并行执行两个或两个以上的作业或程序</p>
<h5 id="提高并行性的技术途径"><a href="#提高并行性的技术途径" class="headerlink" title="提高并行性的技术途径"></a>提高并行性的技术途径</h5><p>(1) 时间重叠： 让多个处理过程在时间上互相错开，如流水线技术</p>
<p>(2) 资源重复 ： 在并行性概念中引入空间因素，以数量取胜，通过重复设置硬件资源，大幅度地提高计算机系统的性能</p>
<p>(3) 资源共享 软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备。多道程序，分时系统就是遵守这一途径而产生的。</p>
<h5 id="单机系统中并行性的发展"><a href="#单机系统中并行性的发展" class="headerlink" title="单机系统中并行性的发展"></a>单机系统中并行性的发展</h5><p>主导作用是时间重叠原理，</p>
<p>实现时间重叠的基础是部件功能专用化，然后构成流水线</p>
<p>资源重复原理的应用，用单机处理机模拟多处理机的功能，形成所谓虚拟机的概念</p>
<h5 id="多机系统中并行性的发展"><a href="#多机系统中并行性的发展" class="headerlink" title="多机系统中并行性的发展"></a>多机系统中并行性的发展</h5><p>紧密耦合系统又叫直接耦合系统</p>
<p>松耦合系统又叫间接耦合系统</p>
<h3 id="计算机指令集结构"><a href="#计算机指令集结构" class="headerlink" title="计算机指令集结构"></a>计算机指令集结构</h3><h4 id="指令集结构的分类"><a href="#指令集结构的分类" class="headerlink" title="指令集结构的分类"></a>指令集结构的分类</h4><p>区别不同指令集结构的主要因素</p>
<p>CPU 中用来存储操作数的存储单元的类型</p>
<ul>
<li>堆栈</li>
<li>累加器</li>
<li>通用寄存器组</li>
</ul>
<p>将指令集结构分为三种类型</p>
<ul>
<li>堆栈结构</li>
<li>累加器结构</li>
<li>通用寄存器结构</li>
</ul>
<p>根据<img src="https://mooc1-2.chaoxing.com/images/Rtiao.png" alt="img">操作数的来源不同，又可以进一步分为</p>
<p>寄存器-存储器结构(RM)(操作数可以来自寄存器)</p>
<p>寄存器-寄存器结构(RR)(操作数都是来自于通用寄存器)，也称为load-store结构，这个名称强调：只有load指令和store指令能够访问存储器。</p>
<p>对于不同类型的指令集结构，操作数的位置，个数，以及操作数给的方式(隐式或显式)也会不同</p>
<ul>
<li>隐式给出： 使用事先约定好的存储单元</li>
<li>显式给出：使用指令字中的操作数字段给出</li>
</ul>
<p>4种指令集结构的操作数位置以及结果的去向</p>
<p>图</p>
<p>通用寄存器结构</p>
<p>现代指令集结构的主流</p>
<p>在灵活性和提高性能方面有明显的优势</p>
<p>跟其他的CPU内部存储单元一样，寄存器的访问速度比存储器块</p>
<p>对于编译器而言，能够更加容易，有效地分配和使用寄存器</p>
<p>寄存器可以用来存放变量</p>
<p>减少对存储器的访问，加快速度</p>
<p>用更少的地址位(相对于储存器地址来说)对寄存器进行寻址</p>
<p>根据ALU指令的操作数的两个特征对通用寄存器型指令集的结构进行进一步细分</p>
<p>ALU指令的操作数个数</p>
<p>3个操作数的指令</p>
<p>两个源操作数，一个目的操作数</p>
<p>2个操作数的指令</p>
<p>其中一个操作数作为源操作数，又作为目的操作数</p>
<p>ALU指令种存储器操作数的个数： 0-3</p>
<p>8 ALU 指令中操作数个数</p>
<p>9通用寄存器型指令集结构进一步细分为三种类型</p>
<p>3种的优缺点</p>
<p>图片</p>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>寻址方式(addressing mode) 是指一种指令集结构如何确定所要访问的数据的地址</p>
<p>一些寻址方式</p>
<p>图片</p>
<h4 id="指令集结构的功能设计"><a href="#指令集结构的功能设计" class="headerlink" title="指令集结构的功能设计"></a>指令集结构的功能设计</h4><p>在确定哪些功能用硬件来实现时，主要考虑的因素有3个，速度，成本与灵活性。</p>
<p>用硬件实现的特点时速度快,成本高，灵活性差。</p>
<p>用软件来实现的特点时速度慢，价格便宜，灵活性好。</p>
<p>一般出现频度高的基本功能用硬件来实现</p>
<p>对指令集的基本要求是： 完整性，规格性，高效率和兼容性。</p>
<p>分类图片</p>
<h5 id="CISC-指令集结构的功能设计"><a href="#CISC-指令集结构的功能设计" class="headerlink" title="CISC 指令集结构的功能设计"></a>CISC 指令集结构的功能设计</h5><p>数量多，功能多样的指令，指令往往达到200 ~ 300 条之多</p>
<h6 id="面向目标程序增强功能"><a href="#面向目标程序增强功能" class="headerlink" title="面向目标程序增强功能"></a>面向目标程序增强功能</h6><p>(1) 增强运算型指令的功能</p>
<p>(2) 增强数据传送指令的功能</p>
<p>(3) 增强程序控制指令的功能</p>
<h6 id="面向高级语言的优化来改进指令集"><a href="#面向高级语言的优化来改进指令集" class="headerlink" title="面向高级语言的优化来改进指令集"></a>面向高级语言的优化来改进指令集</h6><p>(1) 增强对高级语言和汇编器的支持</p>
<p>(2) 高级语言计算机</p>
<h6 id="面向操作系统的优化实现改进指令集"><a href="#面向操作系统的优化实现改进指令集" class="headerlink" title="面向操作系统的优化实现改进指令集"></a>面向操作系统的优化实现改进指令集</h6><h5 id="RISC-指令集的功能设计"><a href="#RISC-指令集的功能设计" class="headerlink" title="RISC 指令集的功能设计"></a>RISC 指令集的功能设计</h5><p>CISC 指令集的问题</p>
<ol>
<li>各种指令的使用频度相差悬殊</li>
<li>指令集庞大，指令条数很多，许多指令的功能又很复杂</li>
<li>许多指令由于操作繁琐，其CPI值比较大</li>
<li>由于指令功能复杂，规整性不好，不利于采用流水线技术</li>
</ol>
<h5 id="指令控制"><a href="#指令控制" class="headerlink" title="指令控制"></a>指令控制</h5><p>控制指令是用来改变控制流的</p>
<p>条件分支(conditional branch)</p>
<p>跳转(jump)</p>
<p>过程调用(call)</p>
<p>过程返回(return)</p>
<p>主要在于分支</p>
<p>分支条件的主要方法及其缺点</p>
<p>图片</p>
<h4 id="操作数的类型和大小"><a href="#操作数的类型和大小" class="headerlink" title="操作数的类型和大小"></a>操作数的类型和大小</h4><p>数据表示(data representation)是指计算机能够直接识别，计算机硬件能够直接识别，指令集可以直接调用的数据类型。</p>
<p>数据结构(data structure)则不同，它是指由软件进行处理和实现的各种数据类型。</p>
<p>表示操作数类型的方法有一下两种</p>
<ul>
<li>由指令中的操作码指定操作数的类型</li>
<li>给数据加上标识(tag)，由数据本身给出操作数类型</li>
<li></li>
</ul>
<h4 id="指令格式的设计"><a href="#指令格式的设计" class="headerlink" title="指令格式的设计"></a>指令格式的设计</h4><p>寻址方式的表示</p>
<p>一种是把它与操作码一起编码，另一种则是设置专门的地址描述符</p>
<p>3种编码格式</p>
<ol>
<li>可变长编码格式</li>
<li>固定长度</li>
<li>混合型</li>
</ol>
<p>图片</p>
<h4 id="MIPS指令集结构"><a href="#MIPS指令集结构" class="headerlink" title="MIPS指令集结构"></a>MIPS指令集结构</h4><h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3><p>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现，把多个处理过程在时间上错开，依次通过各功能段，这样每个子过程就可以和其他子过程并行进行</p>
<ol>
<li>流水线把一个处理过程分解为若干子过程，每个过程由一个专门的部件来实现，因此，流水线实际上是把一个大的处理部件分解为多个独立的工作部件，并依靠它们的并行工作来缩短程序的执行时间</li>
<li>流水线中各段的时间应尽可能相等，否则将引起流水线阻塞，断流，因为时间长的段将成为流水线的瓶颈，此时流水线中的其他部功能部件就不能充分发挥作用，因此瓶颈问题是流水线设计中必须解决的</li>
<li>流水线每一个功能部件的后面都要有一个缓冲寄存器(锁存器), 称为流水线寄存器，其作用是在相邻的两段之间传送数据，以保证提供后面要用到的数据，并把各段的处理工作相互隔离</li>
<li>流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率</li>
<li>流水线需要有通过时间和排空时间。它们分别指顶一个任务和最后一个任务从进入流水线到流出结构的那个时间段。这两个时间段，流水线都不是满载的。经过”通过时间”后,流水线进入满载工作状态，整体流水线的效率才得到充分发挥</li>
</ol>
<h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><h5 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h5><h6 id="单功能流水线和多功能流水线"><a href="#单功能流水线和多功能流水线" class="headerlink" title="单功能流水线和多功能流水线"></a>单功能流水线和多功能流水线</h6><p>这是按流水线所完成的功能来分类</p>
<ol>
<li>单功能流水线 ： 只能完成一种固定功能的流水线</li>
<li>流水线的各段可以进行不同的连接，以实现不同的功能</li>
</ol>
<h6 id="静态流水线与动态流水线"><a href="#静态流水线与动态流水线" class="headerlink" title="静态流水线与动态流水线"></a>静态流水线与动态流水线</h6><p>这是安装统一时间内各段之间的连接方式来对多功能流水线作进一步的分类</p>
<ol>
<li>静态流水线： 在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线： 在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能。</li>
</ol>
<h6 id="部件级，处理机级及处理机间流水线"><a href="#部件级，处理机级及处理机间流水线" class="headerlink" title="部件级，处理机级及处理机间流水线"></a>部件级，处理机级及处理机间流水线</h6><p>这是按流水线的级别来进行分类</p>
<p>部件级流水线</p>
<p>处理机级流水线</p>
<p>处理机间流水线</p>
<h6 id="线性流水线与非线性流水线"><a href="#线性流水线与非线性流水线" class="headerlink" title="线性流水线与非线性流水线"></a>线性流水线与非线性流水线</h6><p>这是按照流水线中是否由回馈回路进行分类</p>
<h6 id="顺序流水线与乱序流数线"><a href="#顺序流水线与乱序流数线" class="headerlink" title="顺序流水线与乱序流数线"></a>顺序流水线与乱序流数线</h6><p>这是根据任务流入和流出的顺序是否相同进行分类</p>
<h4 id="流水线性能指标"><a href="#流水线性能指标" class="headerlink" title="流水线性能指标"></a>流水线性能指标</h4><h5 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h5><h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h4 id="流水线的相关与冲突"><a href="#流水线的相关与冲突" class="headerlink" title="流水线的相关与冲突"></a>流水线的相关与冲突</h4><h5 id="一个经典的5段流水线"><a href="#一个经典的5段流水线" class="headerlink" title="一个经典的5段流水线"></a>一个经典的5段流水线</h5><p>一个经典的5段RISC流水线‘</p>
<p>一条指令的执行过程分为以下5个周期</p>
<p>取指令周期(IF)</p>
<p>指令译码/读存储器周期(ID)</p>
<p>执行/有效地址计算周期(EX)</p>
<p>存储器访问指令: ALU把所指定的存储器的内容与偏移量相加，形成用于访问的有效地址</p>
<p>寄存器-寄存器ALU指令: ALU按照操作码指定的操作对从通用寄存器组种读取的数据进行运算</p>
<p>寄存器-立即数ALU指令: ALU按照操作码指定的操作对从通用寄存器组种读取的理机数进行运算</p>
<p>分支指令:ALU把偏移量与PC值相加，形成转移目标的地址，同时，对在前一周期读出的操作数机型判断，确定分支是否能成功。</p>
<p>存储器访问/分支完成周期(MEM)</p>
<p>load和store指令。如果是load指令，就用上一个周期计算出的有效地址从存储器种读出相应的数据；如果是store指令，就把指定的数据写入写入这个有效地址所指定的存储器单元</p>
<p>分支指令。 如果在前一个周期判定该分支”成功”，就把转移目标地址送入PC.分支指令执行完成</p>
<p>写回周期(WB)</p>
<p>把上面的每一个周期作为一个流水段，在各段之间加上锁存器，这些锁存器称为流水线寄存器</p>
<p>采用流水线方式实现时，首先要保证不会再同一时钟周期要求同一个功能段做两件不同的工作</p>
<h5 id="相关与流水线冲突"><a href="#相关与流水线冲突" class="headerlink" title="相关与流水线冲突"></a>相关与流水线冲突</h5><h6 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h6><p>相关(dependence)是指两跳指令之间存在某种依赖关系。有三种类型: 数据相关(真数据相关)，民相关和控制相关</p>
<p>1 数据相关(data dependence)</p>
<p>对于两条指令i(在前)和j(在后)，如果下述条件之一成立，则称指令j于指令i数据相关：</p>
<ol>
<li>指令j使用i产生的结果</li>
<li>指令j与指令k数据相关，而指令k又与指令i数据相关</li>
</ol>
<p>2名相关(name dependence)</p>
<p>这里的名是指指令访问的寄存器或存储器单元的名称，如果两条指令使用相同的名，但是他们之间并没有数据数据流动，则称这两条指令存在名相关，指令j与指令i之间的名相关有两种</p>
<ol>
<li>反相关(anti-dependence): 如果指令j与指令i读的名称相同，则称指令i和j发生了反相关。反相关指令之间执行顺序必须严格遵守，以保证i读的值是正确的</li>
<li>输出相关(output dependence): 如果指令j和指令i写相同的名，则称指令i和j发生了输出相关，输出镶滚指令的顺序是不能颠倒的</li>
</ol>
<p>与真数据相关不同，名相关的两条指令之间并没有数据的传送，只是使用了相同的名而以。</p>
<p>如果把其中一条指令所用的名换成别的，并不影响另外一条指令的正确执行，因此可以通过改变指令种操作数的名来消除名相关，这就是换名(renaming)技术，对于寄存器操作数进行换名称位寄存器换名(register renaming)</p>
<p>3控制相关(control dependence)</p>
<p>控制相关是指由分支指令引起的相关.它根据分支指令的执行结果来确定后续指令是否执行。</p>
<p>一般来说，为了保证程序应有的执行顺序，必须严格按控制相关确定的顺序执行</p>
<p>控制相关带来的限制</p>
<h6 id="流水线冲突"><a href="#流水线冲突" class="headerlink" title="流水线冲突"></a>流水线冲突</h6><p>流水线冲突(pipeline hazards) 是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能再指定的时钟周期执行</p>
<p>流水线冲突有以下3种类型</p>
<p>1 结构冲突(strutural hazards): 因硬件资源满足不了指令重叠执行的要求而发生的冲突</p>
<p>2数据冲突(data hazards):当指令再流水线种重叠执行时，因需要用到前面指令的执行结果而发生的冲突</p>
<p>3控制冲突(control hazards): 流水线遇到分支指令和其他会改变PC值得指令所引起得冲突</p>
<p>1) 结构冲突</p>
<p>在流水线中处理机中，为了能够使各种处理都能够顺利的重叠执行，需要对功能部件进行流水，或者重复设置资源，如果某种之力组合因为资源冲突而不能正常执行，则称该处理机有结构冲突</p>
<p>2） 数据冲突</p>
<p>当相关的指令靠的足够近时，</p>
<p>可能发生的数据冲突有以下3种</p>
<ul>
<li>写后读冲突(Read After Write,RAW): 指令j用指令i的计算结构，而且在i将结果写入寄存器之前就去读该寄存器，因而得到的是旧值，它对于真数据冲突</li>
<li>写后写冲突(Write After Write,WAW): 指令j和指令i的结果单元(寄存器或存储器单元)相同，而且j在i写入之前久对该单元进行了写入操作，从而导致写入顺序错误，这时结果单元中留下的时i写入的值，而不是j写入的。这种冲突对应于输出相关，写后写冲突仅发生在这样的流水线中：流水线不止一个段可以进行写操作，或者当前某条指令停顿时，允许气后续指令继续前进</li>
<li>读后写冲突(Write After Read,WAR):指令j的结果单元和指令i的源操作数单元相同，而且j在i后读取该单元之前前就读之前进行写操作，导致i读取到的值是错误的，这种冲突是由反相关引起的</li>
</ul>
<p>通过定向技术减少数据冲突引起的停顿</p>
<p>为了减少停顿时间，可以采用一种称为定向(forwarding,也称为旁路或者短路)</p>
<ul>
<li>EX 段和MEM 段之间的流水线寄存器种保存的ALU运算结果总是回到ALU的入口</li>
<li>当定向硬件检测到其哪一个ALU的运算结果写入的结果就是当前ALU操作数的源寄存器时，那么控制逻辑就会选择定向的数据作为ALU的输入，而不采用通用寄存器读出的值</li>
</ul>
<p>需要停顿的数据冲突</p>
<p>不是所有的指令都可以用定向技术</p>
<p>需要设置一个称为流数线互锁机制(pipeline interlock) 用于检测发现数据冲突，并使流数线停顿，直至冲突消失。</p>
<p>依靠编译器解决数据冲突</p>
<p>可以重新组织指令顺序来消除冲突，这种技术被称为(指令调度)</p>
<p>3) 控制冲突</p>
<h4 id="流水线的实现"><a href="#流水线的实现" class="headerlink" title="流水线的实现"></a>流水线的实现</h4><h4 id="向量处理机"><a href="#向量处理机" class="headerlink" title="*向量处理机"></a>*向量处理机</h4><h3 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h3><h4 id="指令级并行-1"><a href="#指令级并行-1" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>概念</p>
<p>几乎所有的处理机都利用流水线来使指令重叠并行执行，以达到提高性能的目的，这种指令之间存在的潜在并行称为<strong>指令级并行</strong>(ILP: Instruction-Level Parallelism)。</p>
<p>如何通过各种可能的技术，获得更多的指令级并行性</p>
<p>硬件+软件技术</p>
<p>1.流水线处理机的实际CPI</p>
<p>理想流水线的CPI加上各类停顿的时钟周期数</p>
<script type="math/tex; mode=display">
CPI_{流水线}=CPI_{理想}+停顿_{结构冲突}+停顿_{数据冲突}+停顿_{控制冲突}</script><p>理想CPI是衡量流水<strong>最高性能</strong>的一个指标</p>
<p>IPC: Instructions Per Cycle(每个时钟周期完成的指令条数)</p>
<p>2.程序基本块</p>
<p>基本程序块: 一段除了入口和出口外不包含其他分直的线性代码片段。</p>
<p>程序平均每5-7条指令就会有一个分支</p>
<p>3.循环级并行: 使一个循环中的不同循环体并行执行</p>
<p>开发循环体中存在的并行性 最常见，最基本</p>
<p>指令级并行的研究重点之一</p>
<p>考虑下述语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;=500;i=i+1) a[i]=a[i]+s;</span><br></pre></td></tr></table></figure>
<p>每一次循环都可以与其他的循环重叠并行执行</p>
<p>每一次循环的内部，却没有任何的并行性</p>
<p>4.最基本的开发循环级并行的技术</p>
<p>循环展开(loop unrolling)技术</p>
<p>采用向量指令和向量数据表示</p>
<p>5.相关与流水线冲突</p>
<p>相关有三种类型:</p>
<p>数据相关，名相关，控制相关</p>
<p>相关是程序固有的一种属性，它反映了程序中指令之间的互相依赖关系</p>
<p>具体的一次相关是否导致实际冲突的发生以及该冲突会带来多长的停顿，则是流水线的属性。</p>
<p>6.可以从两个方面来解决相关问题</p>
<ul>
<li>保持相关，但避免发生冲突</li>
<li>通过代码变换，消除相关</li>
</ul>
<p>7.程序顺序: 由源程序确定的再完全串行方式下指令执行的指令的执行顺序</p>
<p>只有再可能导致错误的情况下，才保持程序顺序</p>
<p>8.控制相关并不是一个必须严格保持的关键属性</p>
<p>9.对于正确地执行程序来说，必须保持的最关键的两个属性是:数据流和异常行为</p>
<p>保持异常行为是指，无论怎么改变指令的执行顺序，都不能改变程序中异常的发生情况</p>
<p>即原来程序中是怎么发生的，改变执行顺序后还是怎么发生的</p>
<p>弱化为:指令顺序的改变不能导致程序中发生新的异常</p>
<p>如果我们能做到保持程序的数据相关和控制相关就能保持程序的数据流的异常行为</p>
<p>数据流: 指数据值从产生者指令到消费者指令的实际流动</p>
<p>分支指令使得数据流具有动态性，因为它使得给定指令的数据可以有多个来源。</p>
<p>仅仅保持数据相关性是不够饿，只有再加上保持控制的顺序，才能够保持程序顺序</p>
<p>有时，不遵守控制相关既不影响异常行为，也不改变数据流</p>
<p>可以大胆的进行指令调度，把失败分支中的指令调度到分支指令之前</p>
<h4 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h4><p>静态调度</p>
<p>依靠编译器对代码进行静态调度，以减少相关和冲突</p>
<p>它不是在程序执行的过程中，而是在编译期间进行代码调度和优化</p>
<p>通过把相关的指令拉开距离来减少可能产生的停顿</p>
<p>动态调度</p>
<p>在程序的执行过程中，依靠专门硬件对代码进行调度，减少数据相关导致的停顿。</p>
<p>优点:</p>
<ul>
<li>能够处理一些在编译时情况不明的相关(比如涉及存储器访问的相关)，并简化了编译器；</li>
<li>能够使本来时面向某一流水线优化编译的代码在其他的流水线(动态调度)上也能高效地执行</li>
</ul>
<p>以硬件复杂性的显著增加为代价</p>
<h5 id="动态调度的基本思想"><a href="#动态调度的基本思想" class="headerlink" title="动态调度的基本思想"></a>动态调度的基本思想</h5><h5 id="Tomasulo-算法"><a href="#Tomasulo-算法" class="headerlink" title="Tomasulo 算法"></a>Tomasulo 算法</h5><p>核心思想:</p>
<ol>
<li>检查数据相关的指令，操作数一旦就绪立刻执行，没就绪则等待；</li>
<li>通过寄存器换名技术消除读后写和写后写冲突</li>
</ol>
<h6 id="Tomasulo的基本结构"><a href="#Tomasulo的基本结构" class="headerlink" title="Tomasulo的基本结构"></a>Tomasulo的基本结构</h6><p><img src="C:\hexo\Blog\pictrue\COS1.png" alt="COS1"></p>
<p>1.保留站</p>
<p>保留站(reservation station) 设置在运算部件的入口，</p>
<p>2.公共数据总线</p>
<p>3.load缓冲器和store缓存器</p>
<p>存放读/写存储器的地址或数据，与保留站类似</p>
<p>load缓冲器的作用</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的load访存，等待存储器的响应</li>
<li>保存已经完成了的load的结果(即从存储器取来的数据),等待CDB传输。</li>
</ul>
<p>store缓冲器的作用</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>保存正在进行的store访存的目标地址，该store正在等待存储数据的到达</li>
<li>保存该sotre的地址和数据，直到存储器部件接收</li>
</ul>
<p>4.浮点寄存器</p>
<p>5.指令队列</p>
<p>6.运算部件</p>
<h6 id="Tomasulo算法的基本执行步骤"><a href="#Tomasulo算法的基本执行步骤" class="headerlink" title="Tomasulo算法的基本执行步骤"></a>Tomasulo算法的基本执行步骤</h6><p>流出</p>
<p>(1) 从指令队列得头部取一条指令，送入保留站。</p>
<p>(2)若操作数就绪，讲操作数直接放入保留站。</p>
<p>(3)若操作数未就绪，讲产生该操作数编号写入保留站。一旦操作数就绪，立刻送入。</p>
<p>(4)对目标寄存器进行预约</p>
<p>执行</p>
<p>(1)对ALU指令来说，计算结果。</p>
<p>(2)对load和store指令来说，计算有效地址，并讲有效地址放回缓冲器</p>
<p>写结果</p>
<p>功能部件计算完毕后，就将计算结果放到CDB上，所有等待计算结果得寄存器和保留站(包括store缓冲器)都同时从CDB上活动所需要得数据</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIV.D F4, F0, F2</span><br><span class="line">SUB.D F10,F4, F6</span><br><span class="line">ADD.D F6, F12,F14</span><br></pre></td></tr></table></figure>
<h5 id="Tomasulo算法详细解"><a href="#Tomasulo算法详细解" class="headerlink" title="Tomasulo算法详细解"></a>Tomasulo算法详细解</h5><p>1.符号含义</p>
<p>r:  分配给当前指令的保留站或者缓冲器单元编号；</p>
<p>RS: 保留站</p>
<p>result: 浮点部件或load缓冲器返回的结果</p>
<p>Regs[]:寄存器组名</p>
<p>rd: 目标寄存器编号</p>
<p>rs,rt: 操作数寄存器编号</p>
<p>imm: 符号扩展后的立即数</p>
<p>以上这三个字段，会出现指令之中，之前说个，rs一般是第一个倍访问的寄存器，rt是第二个被访问的寄存器，rd,是第三个被访问的寄存器</p>
<p>以下会出现在保留站中</p>
<p>Op: 要对源操作数进行的操作</p>
<p>Vj和Vk: 分别为保留站中就绪的操作数字段，这里注意，是就绪的操作数。无论是ALU指令，Load指令还是Store指令，j对应的都是rs,k对应的都是rt.</p>
<p>Qj和Qk: 为保留站中未就绪操作数字段，就是未就绪的操作数，无论是ALU指令，Load指令还是Store指令，j对应的都是rs,k对应的都是rt. 当Qj,Qk为0表示保留站或缓冲器单元中的Vj或Vk字段中的数据就绪。当它们为整数时，这时候保留的时保留号，表示它们正在等待结果</p>
<p>A: 这时个Load和Store的保留站字段，指令流程阶段存的时Imm，执行阶段(算出又地址后)存的时访问的有效地址</p>
<p>Qi: 寄存器状态表，对应的时rd。他时寄存器状态表，不是寄存器，当它为0时，代表对应的寄存器是就绪的;为正整数是，代表被某个保留站中的指令预约了，里面保存的即将写结果的保留站号</p>
<p>2 算法</p>
<p>(1)流出阶段</p>
<p>(a)对于浮点运算指令</p>
<p>进入条件: 有空闲保留站(设为r)</p>
<p>操作和状态表内容修改:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Qi[rs] = <span class="number">0</span>)&#123;         <span class="comment">//检测第一操作数是否就绪</span></span><br><span class="line">    RS[r].Vj&lt;- Regs[rs];<span class="comment">//</span></span><br><span class="line">    RS[r].Qj&lt;- <span class="number">0</span>;       <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;                   <span class="comment">//</span></span><br><span class="line">    RS[r].Qj&lt;-Qi[rs];   <span class="comment">//</span></span><br><span class="line">&#125;                       <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Qi[rt] = <span class="number">0</span>)&#123;         <span class="comment">//</span></span><br><span class="line">    RS[r].Vk&lt;- Regs[rt];<span class="comment">//</span></span><br><span class="line">    RS[r].Qk&lt;- <span class="number">0</span>;       <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;                   <span class="comment">//</span></span><br><span class="line">    RS[r].Qk&lt;-Qi[rt];   <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">RS[r].Busy&lt;- yes;       <span class="comment">//</span></span><br><span class="line">RS[r].Qp&lt;- Op;          <span class="comment">//</span></span><br><span class="line">Qi[rd]&lt;- r;             <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>(b) load和store指令</p>
<p>进入条件: 缓存器有空闲单元(设为r)</p>
<p>操作和状态表内容修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Qi[rs] = <span class="number">0</span>)&#123;</span><br><span class="line">    RS[r].Vj&lt;- Regs[rs];</span><br><span class="line">    RS[r].Qj&lt;- <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    RS[r].Qj&lt;- Qi[rs];</span><br><span class="line">&#125;</span><br><span class="line">RS[r].Busy&lt;- yes;</span><br><span class="line">RS[r].A&lt;- Imm;</span><br></pre></td></tr></table></figure>
<p>对于load指令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qi[rt]&lt;- r;</span><br></pre></td></tr></table></figure>
<p>对于store指令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Qi[rt] = <span class="number">0</span>)&#123;</span><br><span class="line">    RS[r].Vk&lt;- Regs[rt];</span><br><span class="line">    RS[r].Qk&lt;- <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    RS[r].Qk&lt;- Qi[rt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多条指令对于同一个目标寄存器进行多次预约得结果，只保留了最后一个预约，因为前面进行寄存器换名得时候，已经消除了读后和写后相关。</p>
<p>(2)执行阶段</p>
<p>(a)浮点运算指令</p>
<p>进入条件: (RS[r].Qj = 0) 且 (RS[r].Qk = 0);</p>
<p>操作和状态表内修改: 进行计算，产生结果。</p>
<p>(b)load/store指令</p>
<p>进入条件:(RS[r].Qj = 0) 且r成为load/store缓冲队列得头部</p>
<p>操作和状态表内容修改</p>
<p>RS[r].A &lt;- Rs[r].Vj + RS[r].A</p>
<p>对于load指令，在完成有效地址计算后，还要进行:</p>
<p>从Mem[RS[r].A]读取数据</p>
<p>(3)写回阶段</p>
<p>(a)浮点运算指令和load指令</p>
<p>进入条件: 保留站r执行结束,且CDB就绪。</p>
<p>操作和状态表内容修改:</p>
<p>任意x  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Qi[x] = r)&#123;</span><br><span class="line">    Regs[x]&lt;- result;</span><br><span class="line">    Qi[x]&lt;- <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(RS[x].Qj = r)&#123;</span><br><span class="line">	RS[x].Vj&lt;- result;</span><br><span class="line">	RS[x].Qj&lt;- <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(RS[x].Qk = r)&#123;</span><br><span class="line">    RS[x].Vk&lt;- result;</span><br><span class="line">    RS[x].Qk&lt;- <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">RS[r].Busy&lt;- no</span><br></pre></td></tr></table></figure>
<p>(b) store</p>
<p>进入条件: 保留站r执行结束,且<strong>RS[r].Qk = 0</strong></p>
<p>操作和状态表内容修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mem[RS[r].A]&lt;- RS[r].Vk</span><br><span class="line">RS[r].Busy&lt;- no;</span><br></pre></td></tr></table></figure>
<h4 id="动态分支预测技术"><a href="#动态分支预测技术" class="headerlink" title="动态分支预测技术"></a>动态分支预测技术</h4><p>所开发的ILP越多，控制相关的制约就越大，分支预测就要有更高的准确度</p>
<p>本节中介绍的方法对于每个实在周期流出多条指令的处理机来所非常重要</p>
<p>因为:</p>
<ul>
<li>在n-流出的处理机中，遇到分支指令的可能性增加了n倍。要给处理器连续提供指令，就需要预测分支的结果</li>
<li>Amdahl定律告诉我们，机器的CPI越小，控制停顿的相对影响就更大</li>
</ul>
<p>动态分支预测: 在程序运行时，根据分支指令过去的表现来预测其将来的行为</p>
<ul>
<li>如果分支行为发生了变化，预测结果也跟着改变</li>
<li>有更好的预测准确度和适应性</li>
</ul>
<p>分支预测的有效性取决于:</p>
<p>预测的准确性</p>
<p>越策争取和不争取两种情况下的分支开销</p>
<p>决定分支开销的因素:</p>
<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul>
<p>采用动态分支预测技术的目的</p>
<ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址(或指令)</li>
</ul>
<p>需要解决的关键问题</p>
<ul>
<li><p>如何记录分支的历史信息</p>
</li>
<li><p>如何根据这些信息来预测分支的去向(甚至取到指令)</p>
</li>
</ul>
<p>在预测错误时，要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令</p>
<h5 id="采用分支历史表-BHT"><a href="#采用分支历史表-BHT" class="headerlink" title="采用分支历史表(BHT)"></a>采用分支历史表(BHT)</h5><p>BHT基本思想:根据历史看未来。记录下来最近几次分支的成功与否，来预测本次分支是否成功</p>
<p>分支历史表BHT(Baranch History Table)或分支预测缓冲器(Branch Predicition Buffer)</p>
<ul>
<li>最简单的动态分支预测方法</li>
<li>用BHT来记录分支指令最近一次或几次的执行情况，并据此进行预测</li>
</ul>
<p>只有1个预测位的分支预测缓冲</p>
<p>记录分支指令最近一次的历史，BHT中只需要1位二进制</p>
<p>采用两位二进制来记录历史</p>
<ul>
<li>提高预测的准确度</li>
<li>研究结果表明:两位分支预测的性能与多于两位分支预测的性能差不多</li>
</ul>
<p>状态转换:</p>
<p><img src="C:\Users\EndA\AppData\Roaming\Typora\typora-user-images\image-20200417004847846.png" alt="image-20200417004847846"></p>
<p>图片解释</p>
<p>11 和 10 表示预测 分支成功</p>
<p>01 和  00 表示预测 分支不成功</p>
<p>实际上表示只有连续两次预测错误才会更改分支策略</p>
<p>分支预测中的操作有两个步骤:</p>
<p>分支预测:</p>
<ul>
<li>分支指令到达译码段(ID)时，根据从BHT读出的信息进行分支预测</li>
<li>若预测正确，就继续处理后续的指令，流水线没有断流，否则，就要作废已经预取和分析的指令，恢复现场，并从另一条分支路径重新取指令</li>
</ul>
<p>状态修改</p>
<p>BHT方法只有在一下情况才有用:</p>
<p>判断分支是否成功所需的时间大于确定分支目标地址所需的空间</p>
<h5 id="采用分支目标缓冲器BTB"><a href="#采用分支目标缓冲器BTB" class="headerlink" title="采用分支目标缓冲器BTB"></a>采用分支目标缓冲器BTB</h5><p>BTB 基本思想: 也是根据历史看未来，鉴于只记录下来最近一次或者几次分支的成功与否对某些流水线来说作用不大（因为即使是预测分支成功，也不知道下一条指令是啥），分支目标缓冲器BTB连同分支目标指令地址也记下来，因此，称为分支目标缓冲器。</p>
<p>BTB的原理，BTB缓冲的是”当前指令的地址”和分支目标指令的地址</p>
<p>分支指令, 三种情况</p>
<ul>
<li>上一次分支成功的指令，在BTB表中会有记录，这次仍然预测他是成功的，直接用缓冲的分支目标地址去分支目标指令</li>
<li>以前没有执行过的分支指令,在BTB表中不会有记录,不会去分支目标指令，如果这次分支成功了，要将该指令的地址和对应的分支目标指令地址写入BTB</li>
<li>上次分支不成功的指令，和上处理方法一样</li>
</ul>
<p>另外一种形式</p>
<p>在分支目标缓冲器中存放一条或则多条分支目标出的指令，有三个潜在的好处</p>
<ul>
<li>更快的获得分支目标处的指令</li>
<li>可以一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的</li>
<li>我们可以使用称为<strong>分支折叠</strong>(branch folding) 的优化</li>
</ul>
<h5 id="基于硬件的前瞻预测"><a href="#基于硬件的前瞻预测" class="headerlink" title="基于硬件的前瞻预测"></a>基于硬件的前瞻预测</h5><p>对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、流出和执行后续的指令。只是执行指令的结果不是写回到寄存器或存储器，而是放到一个称为 ROB（ReOrder Buffer，再定序缓存）的缓冲器中。等到相应的指令得到“确认（commit）”（即确实是应该执行的）之后，才将结果写入寄存器或存储器。</p>
<ol>
<li>顺序流出指令队列</li>
<li>猜测路径和乱序执行</li>
<li>顺序确认(保证顺序写回)</li>
<li>猜错或则发生异常,没写回的全不算数</li>
</ol>
<h5 id="算法详述"><a href="#算法详述" class="headerlink" title="算法详述"></a>算法详述</h5><p><strong>1.流出阶段</strong></p>
<p>(1)从浮点指令队列的头部取一条指令。如果有空闲的保留站（设为r）且有空闲的ROB项（设为b），就流出该指令；如果保留站或ROB全满，便停止流出指令，直到它们都有空闲的项。 </p>
<p>(2)如果所需要的操作数已经在寄存器或者ROB中就绪，就把它们送入保留站r中，修改r和b的控制字段，表示已被占用。</p>
<p>(3)将ROB项b的编号也要放入保留站r，以便将来执行结果放到CDB时当做标志。</p>
<p>(4)使用ROB编号对浮点寄存器进行预约。 //备注：书上步骤中没提这个，实际上有。</p>
<p><strong>2.执行阶段</strong></p>
<p>(1)如果有操作数尚未就绪，就等待，并不断地监测CDB。</p>
<p>(2)当两个操作数都已就绪后，就可以执行该指令的操作。</p>
<p>(3)Load指令的执行包括计算地址和从内存中读取数据。</p>
<p>(4)Store指令的执行只包括计算地址。</p>
<p><strong>3.写结果阶段</strong></p>
<p>(1)当结果产生后，将该结果连同本指令在流出段所分配到的ROB项的编号放到CDB上，经CDB写到ROB以及所有等待该结果的保留站。</p>
<p>(2)释放产生该结果的保留站。</p>
<p>(3)store指令的操作为:如果要写入存储器的数据已经就绪，就把该数据写入分配给该store指令的ROB项。否则，就监测CDB，直到那个数据在CDB上播送出来，这时才将之写入分配给该store指令的ROB项。</p>
<p><strong>4.确认阶段</strong></p>
<p>(1)其他指令（除分支指令和store指令）：当该指令到达ROB队列的头部而且其结果已经就绪时，就把该结果写入该指令的目标寄存器，并从ROB中删除该指令。 </p>
<p>(2)store指令：处理与上面类似，只是它把结果写入存储器。</p>
<p>(3)分支指令：</p>
<p>情况I：当预测错误的分支指令到达ROB队列的头部时，清空ROB，执行过程从分支指令的后续正常处重新开始。</p>
<p> 情况II：当预测正确的分支指令到达ROB队列的头部时，和非分支指令一样正常确认。</p>
<p>(4)产生异常的指令：在该指令到达ROB头部前不处理。到达ROB头部时，产生中断，清空ROB。此操作能够完成精确的异常处理。</p>
<h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><ul>
<li>速度越块，价格越高(每位)</li>
<li>容量越大，价格越低(每位)</li>
<li>容量越大，速度越慢</li>
</ul>
<p>程序访问的局部性原理</p>
<p>存储系统的多级层次结构</p>
<h5 id="存储系统的性能参数"><a href="#存储系统的性能参数" class="headerlink" title="存储系统的性能参数"></a>存储系统的性能参数</h5><p>1.存储容量S</p>
<p>一般来说，整个存储器系统的容量即是第二级存储器$M_2$的容量,即$S=S_2$</p>
<p>2.存储系统的平均每位价格C</p>
<script type="math/tex; mode=display">
C=\frac{C_1S_1+C_2S_2}{S_1+S_2}</script><p>3.命中率H</p>
<p>命中率(hit ratio)H的定义为，CPU访问存储系统时,在M1中找到所需信息的概率</p>
<script type="math/tex; mode=display">
H=\frac{N_1}{N_1+N_2}</script><p>$N_i$表示访问$M_i$的次数</p>
<p>4.平均访存时间$T_A$</p>
<p>分两种情况考虑CPU的一次访存</p>
<ul>
<li>当命中时，访问时间即为$T_1$.$T_1$常常称为命中时间(hit-time)</li>
<li>当不命中时，在大多数二级存储系统中，若访问的字不在$M_1$中，就必须从$M_2$中把包含所要访问的字的快(或页面)传送到$M_1$之后CPU才可以在$M_1$中访问到这个字，设传送一个信息块所需要的时间为$T_n$,则不命中时的访问时间为$T_2+T_B+T_1=T_1+T_M$其中$T_M=T_B+T_2$称为不命中开销(miss penalty),它是指从向$M_2$发出访问请求把整个数据快调入$M_1$所需的时间</li>
</ul>
<p>考虑到命中和不明中的概率分别是$H$和$1-H$,所以该存储系统的平均访存时间为</p>
<script type="math/tex; mode=display">
T_A=HT_1+(1-H)(T_1+T_M)=T_1+(1-H)T_M=T_1+FT_M</script><h5 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h5><p>大部分计算机都采用了了有Cache(高速缓冲存储器)，主存储器和磁盘存储器(辅存)构成的三级存储系统，</p>
<p><strong>“Cache-主存”层次</strong></p>
<p><strong>“主存-辅存”层次</strong></p>
<h5 id="存储层次的4个问题"><a href="#存储层次的4个问题" class="headerlink" title="存储层次的4个问题"></a>存储层次的4个问题</h5><ul>
<li>当把一个块(页)调入高一层(靠近CPU)存储器时，可以放到哪些位置上(映射规则)</li>
<li>当所要访问的块(页)在高一层存储器中时，如何找到该块(查找算法)</li>
<li>当发生不命中且搞一层存储器已经满时，应该替换哪一块(替换算法)</li>
<li>当进行写访问时，应该进行哪些操作(写策略)</li>
</ul>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><h5 id="基本结构和原理"><a href="#基本结构和原理" class="headerlink" title="基本结构和原理"></a>基本结构和原理</h5><p>Cache是按块进行管理的，Cache和主存均被分割为大小相同的块，信息以块为单位调入Cache，相应地，CPU的访存地址被分割为两部分；块地址和块内位移</p>
<p>[主存地址]=[块地址:块内位移]</p>
<p>工作示意图</p>
<h5 id="映像规则"><a href="#映像规则" class="headerlink" title="映像规则"></a>映像规则</h5><p><strong>1. 全相联映射(fully associative mapping)</strong></p>
<p>主存中的任意一块都可以被放置到Cache的任何一个位置</p>
<p><strong>2. 直接映像(direct mapping)</strong></p>
<p>主存中的每一个块只能被防止到Cache中的唯一一个位置</p>
<p>一般地，如果主存的第i块(即块地址为i)映像到Cache块的第j块，则</p>
<script type="math/tex; mode=display">
j= i \mod M</script><p>M为cache的块数</p>
<p><strong>3. 组相联映像(set associative)</strong></p>
<p>Cache被等分为若干组，每组由若干个块组成。主存中的每一个块可以被防止到Cache中唯一的一个组中的任意一个位置，他是前两种方案的折中</p>
<p>n路组相联是指的每个组有n个块</p>
<p>[主存地址] [标识:索引:块内位移]</p>
<p>块内位移取决于块内多少个字节</p>
<p>索引取决于组数(全相联没有索引)</p>
<p>剩下的为标识</p>
<h5 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h5><p>1.通过查找目录表来实现</p>
<p>目录表的结构</p>
<ul>
<li>主存块的块地址的高位部分，称为标识。</li>
<li>每个主存块能够唯一地由其标识来确定</li>
</ul>
<p>主存地址: [标识:索引:块内位移]</p>
<p>块地址:[标识:索引]</p>
<p>只需要查找候选位置所对应的目录表项</p>
<p>2.并行查找与顺序查找</p>
<p>提高性能的重要思想:主候选位置(MRU块)</p>
<p>3.并行查找的实现方法</p>
<p>相联存储器</p>
<ul>
<li><p>目录$2^g$个相联存储区构成，每个相联存储区的大小为$n\times(h+\log_{2}n)$位</p>
</li>
<li><p>更具所查找的组内块地址，从Cache存储体中读出的多个信息字中选一个，发送给CPU</p>
</li>
</ul>
<p>[标识(h位):索引(g位)]</p>
<p>单体多字存储器+比较器</p>
<p>举例: 4路组相联并行标识比较(比较器得个数及位数)</p>
<p>4路组相联Cache的查找过程</p>
<p>直接映像Cache的查找过程</p>
<p>优缺点</p>
<ul>
<li>不必采用相联存储器，而是按地址访问的存储器来实现</li>
</ul>
<p>…(wait)</p>
<h5 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h5><p>要解决的问题: 当新调入一块,而Cache又被占满时,替换哪一块?</p>
<ul>
<li>直接映像Cache中的替换很简单 (只有一个块)</li>
<li>在组相联和全相联Cache中,则又多个块提供选择</li>
</ul>
<p>主要的替换算法有三种</p>
<ul>
<li>随机法</li>
<li>先进先出法(FIFO)</li>
<li>最近最少使用法LRU</li>
</ul>
<p>LRU</p>
<p>选择近期最少被访问的块作为被替换的块。</p>
<p>实际上选择最久没有被访问过的块作为被替换的块</p>
<p>命中率最高</p>
<p>LRU和随机法分别因其不命中率低和实现简单而被广泛采用</p>
<p>对于容量比较大的Cache，LRU和随机法的命中率差别不大</p>
<p>LRU算法的硬件实现</p>
<p>堆栈法</p>
<p>用一个堆栈来记录组相联Cache的同一组中各块被访问的先后次序</p>
<p>用堆栈元素的物理位置来反应先后次序</p>
<p>栈底记录的时该组最早被访问的块</p>
<p>当需要替换时，从栈底得到应该被替换的块</p>
<p>堆栈中的内容必须动态更新</p>
<p>当Cache访问命中时，通过用块地址进行相联查找，在堆栈找到相应的元素，然后把改元素的上面所有元素下压一个位置，同时把本次访问的块地址抽出来，从上面压入栈顶，而元素下面的所有元素则保持不动</p>
<p>如果Cache访问不命中，则把本次访问的地址从最上面压入栈顶，堆栈中所有原来的元素都下移一个位置。如果Cache中该组已经没有空闲块，就要替换一个块，这时从栈底被挤出去的块地址就是需要被替换的块的块地址</p>
<p>所需要硬件</p>
<p>需要为每一组都设置一个项数与相联读相同的小堆栈,每一项的位数为$\log_2 n$位</p>
<p>硬件堆栈所需的功能</p>
<p>相联比较，能够全部下移，部分下移动，和从中间取出一项的功能</p>
<p>速度较低，成本较高</p>
<p>比较对法</p>
<p>让各块两两组合，构成比较对，每一个比较对用一个触发器的状态来表示它所相关的两个块最近一次被访问的远近次序，再经过门电路就可找到LRU块</p>
<p>(wait)</p>
<h5 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h5><p>保证一致性</p>
<p>CASE1 写命中，即CPU要访问的数据在Cache中找到了。这个时候有两种策略</p>
<p>(1) 写直达</p>
<p>(2) 写回法</p>
<p>CASE2 写失效。即CPU要访问的数据在Cache中没有找到。这时候有两种策略</p>
<p>(1)按写分配</p>
<p>(2)不按写分配</p>
<h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><h5 id="Cache的性能分析"><a href="#Cache的性能分析" class="headerlink" title="Cache的性能分析"></a>Cache的性能分析</h5><p>公式1 </p>
<script type="math/tex; mode=display">
平均访存时间=命中时间+不命中率\times 不命中开销</script><p>公式2</p>
<script type="math/tex; mode=display">
CPU时间=(CPU执行周期数+访存次数\times 不命中率\times 不命中开销)\times时钟周期时间</script><p>公式3</p>
<script type="math/tex; mode=display">
CPU时间=(CPU执行周期数+存储器停顿周期数)\times 时钟周期时间</script><p>4 Cache不命中对于一个CPI较小而时钟频率较高CPU来说，影响是双重的</p>
<ul>
<li>$CPI_{execution}$较低，固定周期数的Cache不命中开销的相对影响就越大</li>
<li>在计算CPI时，不命中开销的单位是时钟周期数时钟频率高的CPU不命中开销比较大，其CPI中存储器停顿这部分也就比较大</li>
</ul>
<p>改进:</p>
<p>减低不命中率</p>
<p>降低不命中开销</p>
<p>减少命中时间</p>
<h4 id="降低Cache不命中率"><a href="#降低Cache不命中率" class="headerlink" title="降低Cache不命中率"></a>降低Cache不命中率</h4><h5 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h5><p>有三种类型的不命中:</p>
<ol>
<li>强制性不命中: 第一次访问一个块的时候，该块不在Cache中，需要重下一级存储器中调入Cache</li>
<li>容量不命中:程序执行的时候,所需要的块不能全部调入Cache中，随着程序的执行，某些块不得不被替换，若有被重新访问，就发生了不命中</li>
<li>冲突不命中: 组相联或者直接映像中，太多块映射到同一组(或同一块)上，会发生冲突</li>
</ol>
<ol>
<li>相联度越高，冲突不命中就越少</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受Cache容量的影响，单容量不命中却随着容量的增加而减少</li>
</ol>
<p>从上面看来，可以</p>
<ol>
<li>减少强制性不命中 — 增加块大小</li>
<li>减少容量不命中 — 增加容量</li>
<li>减少冲突不命中 — 提高相联度</li>
</ol>
<p>但是使用一种方法提高某一项性能的同时，可能会牺牲其他方面的性能</p>
<h5 id="增加Cache块大小"><a href="#增加Cache块大小" class="headerlink" title="增加Cache块大小"></a>增加Cache块大小</h5><h5 id="增加Cache的容量"><a href="#增加Cache的容量" class="headerlink" title="增加Cache的容量"></a>增加Cache的容量</h5><h5 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h5><h5 id="伪相联Cache"><a href="#伪相联Cache" class="headerlink" title="伪相联Cache"></a>伪相联Cache</h5><h4 id="减少Cache不命中开销"><a href="#减少Cache不命中开销" class="headerlink" title="减少Cache不命中开销"></a>减少Cache不命中开销</h4><h5 id="采用两级Cache"><a href="#采用两级Cache" class="headerlink" title="采用两级Cache"></a>采用两级Cache</h5><p>增加一级Cache</p>
<ul>
<li>第一级Cache(L1)小而快</li>
<li>第二级Cache(L2)容量大</li>
</ul>
<p>性能分析</p>
<script type="math/tex; mode=display">
平均访存时间=命中时间_{L1}+不命中率_{L1}\times 不命中开销_{L1}
\\
不命中开销_{L1}=命中时间_{L2}+不命中率_{L2}\times 不命中开销_{L2}</script><p>局部命中率与全局不命中率</p>
<script type="math/tex; mode=display">
局部命中率=\frac{该级Cache的不命中次数}{到达该级Cache的访问次数}
\\
全局不命中率=\frac{该级Cache的不命中次数}{CPU发出的访存的总次数}
\\
全局不命中率_{L2}=不命中率_{L1}\times 不命中率_{L2}</script><p>评价第二级Cache时，应该使用全局不命中率这个指标，它指出了在CPU发出的访存中，究竟有多大比例时穿过各级Cache,最终达到存储器的</p>
<p>采用两级Cache时，每条指令的平均访存停顿时间:</p>
<script type="math/tex; mode=display">
每条指令的平均访存停顿时间=\\
每条指令的平均不命中次数_{L1}\times 命中时间_{L2}\\
每条指令的平均不命中次数_{L2}\times 不命中开销_{L2}</script><p>一些结论</p>
<p>\\after</p>
<h5 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h5><ol>
<li>读不命中，需要访存时，可能存储器还未更新，要读入的内容尚在写缓冲区中，若推迟读访问，直到写缓冲区的数据都写入主存，会增加读命中时间</li>
<li>不等写缓冲区清空，读访问不命中的时候，直接在写缓冲区里面找时有需要的数据</li>
</ol>
<p>Cache中的写缓冲器导致对存储器访问的复杂化，在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存</p>
<p>解决方法:</p>
<ul>
<li>推迟读不命中的处理(读不命中的开销增加)</li>
<li>检查写缓冲器中内容</li>
</ul>
<p>在写回法Cache中，也可采用写缓冲器</p>
<h5 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h5><p>提高些缓冲器的效率</p>
<p>写直达Cache</p>
<p>依靠写缓冲来减少对下一级存储器写操作的时间</p>
<ul>
<li>如果缓冲器为空，就把数据和相应地址写入该缓冲器。(从CPU的角度，写操作完成)</li>
<li><p>如果写缓冲器中已经有待写入的数据，就要把这次的写入地址与缓冲器已有的所有地址进性比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并</p>
</li>
<li><p>如果写缓冲器满足又没有能进行写合并的项，就必须等待</p>
</li>
</ul>
<p>提高了写缓冲器的空间利用率，而且还能减少因写缓冲器而要进行的等待时间</p>
<h5 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h5><p>请求字</p>
<ul>
<li>从下一级存储器调入Cache的快中，只有一个字是立即需要的，这个字称为请求字</li>
</ul>
<p>应该尽早把请求字发送给CPU</p>
<ul>
<li>尽早重启动: 调块时，从块的起始位置开始读起，一旦请求字达到，就立即发送给CPU,让CPU继续执行</li>
<li>请求字优先: 调块时，从请求字所在的位置读起。这样，第一个读出的字便时请求字。将之立即发送个CPU</li>
</ul>
<p>Cache块小或者下一条指令正好访问同一块Cache</p>
<h5 id="非阻塞Cache技术"><a href="#非阻塞Cache技术" class="headerlink" title="非阻塞Cache技术"></a>非阻塞Cache技术</h5><p>非阻塞Cache: Cache 不命中时仍允许CPU进行其他的命中访问。即允许”不命中下命中”。</p>
<p>进一步提高性能:</p>
<ul>
<li>“多重不命中下命中”</li>
<li>“不命中下命中”</li>
</ul>
<p>可以同时处理的不命中次数越多，所能带来的性能上的提高就越大</p>
<p>简单的”一次不命中下命中”就几乎可以得到所有的好处</p>
<h4 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h4><p>Cache的访问时间往往会限制处理器的时钟频率</p>
<h5 id="容量小，结构简单的Cache"><a href="#容量小，结构简单的Cache" class="headerlink" title="容量小，结构简单的Cache"></a>容量小，结构简单的Cache</h5><p>硬件越简单，速度就越快</p>
<p>应使Cache足够小(物理空间)，以便于可以与CPU一起放在同一块芯片上</p>
<p>折衷方案(?) 把标识放在片内，把Cache的数据存储器放在片外</p>
<h5 id="虚拟Cache"><a href="#虚拟Cache" class="headerlink" title="虚拟Cache"></a>虚拟Cache</h5><p>物理Cache</p>
<ul>
<li>使用物理地址进行访问的传统Cache</li>
<li>标识存储器中存放的时物理地址，进行地址检测也是用物理地址</li>
<li>缺点:地址转xing换和访问Cache串行进行，访问速度慢</li>
</ul>
<p>虚拟Cache</p>
<ul>
<li>可以直接用虚拟地址进行访问的Cache。标识存储器存放的时虚拟地址，进行地址检测用的也是虚拟地址。</li>
<li>优点<ul>
<li>在命中时不需要地址转换，省去了地址转换的时间。即使不命中地址转换和访问Cache也是并行的，其速度比物理Cache块很多</li>
</ul>
</li>
</ul>
<p>并非都采用虚拟Cache</p>
<ul>
<li>虚拟Cache的清空问题<ul>
<li>解决方法: 在地址标识中增加PID字段</li>
</ul>
</li>
<li>同义和别名<ul>
<li>解决方法: 反别名法，页着色</li>
</ul>
</li>
</ul>
<p>虚拟索引+物理标识</p>
<ul>
<li>优点：兼得虚拟Cache和物理Cache的好处</li>
<li>局限性：Cache容量受到限制<ul>
<li>Cache容量$\leq$ 页大小$\times$ 相联读</li>
</ul>
</li>
</ul>
<p>硬件散列变换</p>
<h5 id="Cache访问流水化"><a href="#Cache访问流水化" class="headerlink" title="Cache访问流水化"></a>Cache访问流水化</h5><ol>
<li>对第一级Cache的访问按流水方式组织</li>
<li>访问Cache需要多个时钟周期才可以完成</li>
</ol>
<h5 id="踪迹Cache"><a href="#踪迹Cache" class="headerlink" title="踪迹Cache"></a>踪迹Cache</h5><p>开发指令级并行所遇到的一个挑战是:</p>
<p>当要每个时钟周期流出超过4条指令时，要提供足够多条彼此互不相关的指令时很困难的</p>
<p>一个解决方法: 采用踪迹 Cache</p>
<p>存放CPU所执行的动态指令序列</p>
<ul>
<li>包含了由分支预测展开的指令，该分支预测事否正确需要在取到该指令时进行确认</li>
</ul>
<p>优缺点</p>
<ul>
<li>地址映像机制复杂</li>
<li>相同的指令序列</li>
</ul>
<h4 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h4><p>主存的主要性能指标: 延迟和带宽</p>
<p>以往:</p>
<p>Cache主要关系延迟，I/O主要关系带宽</p>
<p>Cache 关心两者</p>
<p>并行主存系统式在一个访存周期内能并行访问多个存储子的存储器</p>
<ul>
<li>能够有效地提高存储器的带宽</li>
</ul>
<h5 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h5><p>能提高带宽</p>
<p>优缺点:</p>
<ul>
<li>优点: 实现简单</li>
<li>缺点: 访存效率不高</li>
</ul>
<p>原因:</p>
<ul>
<li>分支指令使得后面指令无效</li>
<li>不一定都是有用的</li>
<li>写入可能变得复杂</li>
</ul>
<h5 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h5><p>由多个单字存储体构成，每个体由自己的地址寄存器以及地址译码和读/写驱动等电路，如下图式四个体交叉存储器</p>
<p>//图片</p>
<p>高位和低位</p>
<h5 id="避免存储体冲突"><a href="#避免存储体冲突" class="headerlink" title="避免存储体冲突"></a>避免存储体冲突</h5><p>体冲突: 两个请求要求访问同一个体</p>
<p>减少体冲突次数的一种方法: 采用许多体</p>
<p>解决体冲突的方法</p>
<ul>
<li>软件方法(编译器)<ul>
<li>循环交换优化</li>
<li>扩展数组的大小，使之不是2的幂</li>
</ul>
</li>
<li>硬件方法<ul>
<li>使体数为素数</li>
<li>体内地址=地址 A mod (存储体中的字数)</li>
</ul>
</li>
</ul>
<h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><h5 id="基本概率"><a href="#基本概率" class="headerlink" title="基本概率"></a>基本概率</h5><h5 id="快速地址转换技术"><a href="#快速地址转换技术" class="headerlink" title="快速地址转换技术"></a>快速地址转换技术</h5><p>地址变换缓冲器TLB</p>
<p>TLB中的项由两部分构成: 标识和数据</p>
<p>标识中存放的式虚地址的一部分</p>
<p>数据部分存放的则是物理页帧号，有效位，存储保护信息，使用位，修改位等</p>
<p>一般保证TLB比Cache的标识存储器更小,更快</p>
<p>保证TLB的读出操作不会使Cache的命中时间延长</p>
<h3 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h3><h4 id="输入-输出系统的性能"><a href="#输入-输出系统的性能" class="headerlink" title="输入/输出系统的性能"></a>输入/输出系统的性能</h4><p>输入/输出系统简称I/O系统</p>
<p>它包括:</p>
<ul>
<li>I/O设备</li>
<li>I/O设备与处理机的连接</li>
</ul>
<p>I/O系统是计算机系统的一个重要组成成分</p>
<ul>
<li>完成计算机与外界的信息交换</li>
<li>给计算机提供大容量的外部存储器</li>
</ul>
<p>按照主要完成的工作进行分类</p>
<p>存储I/O系统</p>
<p>通信I/O系统</p>
<p>系统的响应时间</p>
<p>从用户输入命令开始，得到结果所花费的时间</p>
<p>由两部分构成:</p>
<p>I/O 系统相应时间</p>
<p>CPU 处理时间</p>
<p>误区： 使用多进程技术可以忽略I/O性能对系统性能的影响</p>
<p>多进程技术只能够提高系统吞吐率，并不能减少系统相应时间</p>
<p>进程切换时可能需要增加I/O操作</p>
<p>课切换的进程数量有限，当I/O处理较慢时，仍然会导致CPU处于空闲状态</p>
<p>评价I/O系统性能的参数主要有:</p>
<p>连接特性</p>
<p>I/O系统的容量</p>
<p>响应时间和吞吐率</p>
<p>另外一种衡量I/O系统性能的方法</p>
<p>考虑I/O操作对CPU的打扰情况</p>
<p>即考查某个进程在执行时，由于其他进程的I/O操作，使得该进程的执行时间增加了多少</p>
<h4 id="输入-输出系统的可靠性，可用性和可信性"><a href="#输入-输出系统的可靠性，可用性和可信性" class="headerlink" title="输入/输出系统的可靠性，可用性和可信性"></a>输入/输出系统的可靠性，可用性和可信性</h4><p>处理器性能已经很高，人们更加关注系统可靠性</p>
<p>反映外设可靠性能的参数有:</p>
<ul>
<li>可靠性(Reliability)</li>
<li>可用性(Availability)</li>
<li>可用性(Dependability)</li>
</ul>
<p>系统的可靠性: 系统从某个初始参考电开始一直连续提供服务的能力</p>
<p>用平均无故障时间MTTF(Mean Time to Failure)来衡量</p>
<p>MTTF 的倒数就是系统的失效率</p>
<p>如果系统种的每个模块的生存期服从指数分布，则系统整体的失效率是各部件的失效率之和</p>
<p>系统的可用性: 系统正常工作的时间在连续连词正常服务间隔时间种所占的比率</p>
<p>$可用性=\frac{MTTF}{MTTF+MTTR}$</p>
<p>MTTF+MTTR: 平均失效间隔时间MTBF(MTBF)</p>
<p>系统的可信性: 服务的质量. 即在大多程度可以合理的认为服务是可靠的(不可以度量)</p>
<p>提高系统组成部件可靠性的方法</p>
<p>有效构建方法(valid construction)</p>
<p>在构造系统的过程种消除故障隐患，这样建立起来的系统就不会出现故障</p>
<p>纠错方法(error correction)</p>
<p>在系统构建种采用容错的方法，这样即使出现故障，也可以通过容错信息保证系统正常工作。</p>
<h4 id="廉价磁盘冗余阵列"><a href="#廉价磁盘冗余阵列" class="headerlink" title="廉价磁盘冗余阵列"></a>廉价磁盘冗余阵列</h4><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>在计算机系统种，各子系统之间可以通过总线互相连接</p>
<p>优点: 成本低，多样性</p>
<p>主要缺点: 他是由不同的外设分时共享的，形成了信息交换的瓶颈，从而限制了系统中总的I/O吞吐量</p>
<h5 id="总线的设计"><a href="#总线的设计" class="headerlink" title="总线的设计"></a>总线的设计</h5><p>技术难点</p>
<p>一个重要原因: 总线上信息传送的速度极大地受限于各种物理因素</p>
<p>总线的长度，设备的数目，信号的强度等等，这些物理因素限制了总线性能的提高</p>
<p>I/O操作相应快和高吞吐量可能造成设计需求上的冲突</p>
<p>设计总线时需要考虑的一些问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>高性能</th>
<th>低价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>总线宽度</td>
<td>独立的地址和数据总线</td>
<td>数据和地址分时共用一套总线</td>
</tr>
<tr>
<td>数据总线宽度</td>
<td>越宽越快</td>
<td>越窄越便宜</td>
</tr>
<tr>
<td>传输快大小</td>
<td>块越大总线开销越小</td>
<td>单字传输更简单</td>
</tr>
<tr>
<td>总线主设备</td>
<td>多个(需要仲裁)</td>
<td>单个(无需仲裁)</td>
</tr>
<tr>
<td>分离事务</td>
<td>采用一一分离的请求包和回答包能够提高总线宽度</td>
<td>不采用一一持续连接成本更低，而且延迟更小</td>
</tr>
<tr>
<td>定时方式</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>分离总线事务</p>
<p>(又称: 流水总线，悬挂总线，包交换总线)</p>
<p>在有多个主设备时，可以通过打包技术来提高总线带宽</p>
<p>基本思想</p>
<p>将总线事务分成请求和应答两部分</p>
<p>在请求和应答之间的空闲时间内，总线可以供其他的I/O使用，这样就不必在整个I/O过程都独占总线</p>
<p>总线同步</p>
<p>包含一个供总线上所有设备使用的时钟，并且这些设备时基于该时钟按照一个固定的协议来发送地址和数据的</p>
<p>优点: 速度快，成本低</p>
<p>缺点: 总线操作都必须以同样的时钟频率进行</p>
<p>异步总线</p>
<p>没有同一的参考时钟，每个设备都有各自的定时方法</p>
<p>采用握手协议</p>
<p>总线标准和实例</p>
<p>和CPU的连接</p>
<p>I/O总线的物理连接方式有两种选择</p>
<p>连接到存储器上，更常见的连接到Cache</p>
<p>I/O总线连接到存储器总线上的方式</p>
<p>一种典型的组织结构</p>
<p>CPU对I/O设备的编制有两种方式</p>
<p>存储器映射I/O(也称为统一编址)</p>
<p>将一部分存储器地址空间分配给I/O设备，用load指令和store指令对这些地址进行读写将引起I/O设备的数据传输</p>
<p>给I/O设备独立编址</p>
<p>需要在CPU种设置专用的I/O指令访问I/O设备</p>
<p>CPU需要发出一个标志信号来表示所访问低地址时I/O设备的地址</p>
<p>CPU与外部设备进行输入输出的方式可分为4种</p>
<p>程序查询</p>
<p>中断</p>
<p>DMA</p>
<p>通道</p>
<h4 id="通道处理机"><a href="#通道处理机" class="headerlink" title="通道处理机"></a>通道处理机</h4><p>通道处理机能够负担外围设备的大部分I/O工作.</p>
<p>通道处理机(简称通道): 专门负责整个计算机系统的输入/输出工作。通道处理机只能执行有限的一组输入/输出指令</p>
<h5 id="通道的作用和功能"><a href="#通道的作用和功能" class="headerlink" title="通道的作用和功能"></a>通道的作用和功能</h5><p>1 程序控制，中断和DMA方式管理外围设备会引起两个问题</p>
<p>所有外设的输入/输出工作均由CPU承担，CPU的计算工作经常被打断而区处理输入/输出的事务，不能充分发挥CPU的计算能力</p>
<p>大型计算机系统的外设虽然很多，但同时工作的机会不是很多</p>
<p>解决上述问题的方法: 采用通道处理机</p>
<p>一个典型的由CPU,通道，设备控制器，外设构成的4级层次结构的输入/输出系统</p>
<p>通道的功能</p>
<p>接收CPU发来的I/O指令，并根据指令要求选择指定的外设与通道相连接</p>
<p>执行通道程序</p>
<p>从主存中逐条取出通道指令，堆通道指令进行译码，并根据需要相被选中的设备控制器发出各种操作命令。</p>
<p>给出外设中要进行读/写操作的数据所在的地址(如磁盘存储器的柱面号，磁头号，扇区号等)</p>
<p>给出主存缓冲区的首地址</p>
<p>该缓冲区存放从外设输入的数据或者将要输出到外设中区的数据</p>
<p>控制外设与主存缓冲区之间的数据传送的长度</p>
<p>对传送的数据个数进行计数，并判断数据传送是否结束</p>
<p>指定传送工作结束时要进行的操作</p>
<p>例如: 将外设的中断请求及通道的中断请求送往CPU等</p>
<p>检查外设的工作是否正常，并将该状态信息送往主存单元保存。</p>
<p>在数据传输过程中完成必要的格式变换</p>
<p>例如: 吧字拆分为字节，或者把字节装配成字等</p>
<p>通道的主要硬件</p>
<p>寄存器</p>
<p>数据缓冲寄存器</p>
<p>主存地址计数器</p>
<p>传输字节数计数器</p>
<p>通道命令字寄存器</p>
<p>通道状态字寄存器</p>
<p>控制逻辑</p>
<p>分时控制</p>
<p>地址分配</p>
<p>数据传送，装配和拆分等</p>
<p>通道对外设的控制通过输入/输出接口和设备控制器进行</p>
<p>通道与设备控制器之间一般采用标准的输入/输出接口来连接</p>
<p>通道通过接口标准接口把操作命令送到设备控制器</p>
<p>设别控制器解释并执行这些通道命令，完成ming’l</p>
<h5 id="通道的工作过程"><a href="#通道的工作过程" class="headerlink" title="通道的工作过程"></a>通道的工作过程</h5><p>1.通道完成一次数据输入/输出的工作过程</p>
<p>在用户程序种使用访管指令进入管理程序，由管理程序生成一个通道程序，并启动通道</p>
<p>用户在目标程序种设置一条广义指令，通过调用擦欧总系统的管理程序来实现。</p>
<p>管理程序根据关于指令提供的参数来编制通道程序。</p>
<p>启动输入/输出指令是一条主要的输入/输出指令，属于特权指令。</p>
<p>工作流程</p>
<p>图片</p>
<p>通道处理机执行通道程序，完成指定的数据输入/输出工作</p>
<p>通道处理机执行通道程序于与CPU执行用户程序是并行的。</p>
<p>通道程序结束后向CPU发中断请求。</p>
<p>CPU执行程序和通道执行程序的时间关系</p>
<p>图片</p>
<h5 id="通道的种类"><a href="#通道的种类" class="headerlink" title="通道的种类"></a>通道的种类</h5><p>根据信息传送方式的不同，将通道分为三种类型</p>
<p>字节多路通道</p>
<p>数据通道</p>
<p>数组多路通道</p>
<p>三种类型的通道与CPU,设备控制器和外设的连接关系</p>
<p>1.字节多路通道</p>
<p>为多台低速或中速的外设服务</p>
<p>以字节交叉的方式分时轮流地为它们服务</p>
<p>以字节多路通道可以包含多个子通道，每个子通道连接一台设备控制器</p>
<p>2.选择通道</p>
<p>为多台高速外围设备服务</p>
<p>在一段时间内只为一台高速外设独占使用</p>
<p>选择通道的硬件</p>
<p>5个寄存器</p>
<p>数据缓冲寄存器，设备地址寄存器，主存地址计数器，交换字节计数器，设备状态/控制寄存器</p>
<p>格式变换部件</p>
<p>用于在主存和设备之间进行字与字节的拆分和装配</p>
<p>通道控制部件</p>
<p>3.数组多路通道</p>
<p>设用于高速设备</p>
<p>多次选择一个高速设备后传送一个数据块，轮流为多台设备服务</p>
<p>数组多路通道之所以能够并行地为多台高速设备服务，是因为虽然其所连设备的传输速率很高，但寻址等辅助操作时间很长。</p>
<h5 id="通道种的数据传送过程与流量分析"><a href="#通道种的数据传送过程与流量分析" class="headerlink" title="通道种的数据传送过程与流量分析"></a>通道种的数据传送过程与流量分析</h5><p>通道流量</p>
<p>一个通道在数据传送周期，单位时间内能够传送的数据量。所用单位一般为Bps.</p>
<p>又称为通道吞吐率，通道数据传输率等</p>
<p>通道最大流量</p>
<p>一个通道在满负荷工作状态下的流量.</p>
<p>参数的定义</p>
<p>$T_s$: 设备选择时间，从通道响应设备发出的数据传送请求开始，到通道实际为这台设备传送数据所需要的时间。</p>
<p>$T_D$: 传送一个字节所用的时间</p>
<p>p: 在一个通道上连接的设备台数，且这些设备同时都在工作</p>
<p>n: 每台设备传送的字节数，这里设备每台设备传送的字节数都相同</p>
<p>k:数组多路通道传输的一个数据块种包含的字节数。</p>
<p>在一般情况下，k&lt;n.对于磁盘，磁带等磁表面存储器，通常k=512.</p>
<p>T: 通道完成全部数据传送工作所需要的时间。</p>
<p>1.字节多路通道</p>
<p>数据传送过程</p>
<p>通道每连接一台外设，只传送一个字节，然后又与另一台设备连接，并传送一个字节。</p>
<p>p台设备每台传送n个数据总共需要的时间为</p>
<p>$T_{BYTE}=(T_S+T_D)\times p \times n$</p>
<p>最大流量</p>
<p>$f_{MAX-BYTE}=\frac{pn}{(T_S+T_D)pn}=\frac{1}{T_S+T_D}$</p>
<p>实际流量是在连接在这个通道上的所有设备的数据传送率之和</p>
<p>$f_{BYTE}=\sum\limits_{i=1}^{p}f_i$</p>
<p>$f_i$:第i台设备的实际数据传输率</p>
<p>选择通道</p>
<p>在一段时间内只能单独为一台高速外设服务，当这台设备的数据传送工作全部完成后，通道才能为另一台设备服务</p>
<p>p台设备每台传送n个数据总共所需的时间</p>
<p>$T_{SELECT}=(\frac{T_S}{n}+T_D)\times p\times n$</p>
<p>最大流量</p>
<p>$f_{MAX-SELECT}=\frac{pn}{(\frac{T_S}{n}+T_D)pn}=\frac{1}{\frac{T_s}{n}+T_D}$</p>
<p>多组数据通道</p>
<p>工作过程</p>
<p>p台设备每天传送n个数据总共所需的时间为</p>
<p>$T_{BLOCK}=(\frac{T_s}{k}+T_D)\times p\times n$</p>
<p>$f_{MAX-BLOCK}=\frac{pn}{(\frac{T_S}{n}+T_D)pn}=\frac{1}{\frac{T_s}{n}+T_D}$</p>
<p>选择通道和数组多路通道的实际流量就是连接在这个通道上的所有设备种数据流量最大的那一个。</p>
<p>$f_{BLOCK}\leq \max\limits_{i=1}^{p} f_i$</p>
<p>$f_{SELECT}\leq \max\limits_{i=1}^{p} f_i$</p>
<p>各种通道的实际流量应该不大于通道的最大流量</p>
<p>$f_{BYTE}\leq f_{MAX-BYTE}$</p>
<p>$f_{BLOCK}\leq f_{MAX-BYTE}$</p>
<p>$f_{SELECT}\leq f_{MAX-BYTE}$</p>
<p>两边的差值越小，通道的利用率就越高。</p>
<p>等两边相等时，通道处于满负荷工作状态。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://p.ananas.chaoxing.com/star3/190_190c/548e30464963ff55a1ebcf90a4374769.jpg" alt="img"></p>
<script type="math/tex; mode=display">
加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}
\\
=\frac{1}{(1-可改进比例)+\sum\frac{可改进比例}{部件加速比}}
\\

但是这里所指明的的是指令所占比例,所以我们应该要用第一个公式\\
可以得到 :加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}
\\=\frac{9\times10^6(11.1\%\times2+33.3\%\times 20+38.9\%\times 10+16.7\%\times 4)}{9\times10^6(11.1\%\times1+33.3\%\times15+38.9\%\times 3+16.7\%\times 1)}
=1.776
\\
如果要使用公式2，我们需要先算所占比例\\
指令1 所占比例: \frac{9\times 10 ^6 \times11.1\% * 2}{9\times10^6(11.1\%\times2+33.3\%\times 20+38.9\%\times 10+16.7\%\times 4)}

=0.020
\\
指令1 加速比: \frac{2}{1}=2
\\

指令1 所占比例: \frac{9\times 10 ^6 \times33.3\% * 20}{9\times10^6(11.1\%\times2+33.3\%\times 20+38.9\%\times 10+16.7\%\times 4)}

=0.582
\\
指令2 加速比: \frac{20}{15}=\frac{4}{3}
\\

指令3 所占比例: \frac{9\times 10 ^6 \times38.9\% * 10}{9\times10^6(11.1\%\times2+33.3\%\times 20+38.9\%\times 10+16.7\%\times 4)}

=0.340
\\
指令3 加速比: \frac{10}{3}=2
\\
指令4 所占比例: \frac{9\times 10 ^6 \times11.1\% * 2}{9\times10^6(11.1\%\times2+33.3\%\times 20+38.9\%\times 10+16.7\%\times 4)}

=0.058
\\
指令4 加速比: \frac{4}{1}=4
\\

然后用公式2计算


\\
\frac{1}{(1-可改进比例)+\sum\frac{可改进比例}{部件加速比}}
\\
=\frac{1}{(1-1)+ { 
\frac{0.020}{2}+ 
\frac{0.582}{\frac{4}{3}} + 
\frac{0.340}{\frac{10}{3}} + 
\frac{0.058}{4} } }
=1.776</script><p>例题 假设一台计算机的I/O处理时间占相应时间的10%,当I/O性能保持不变，而对CPU的性能分别提高10倍和100倍时，该计算机的性能会发生什么样的变化</p>
<p>设改进前程序的执行时间为1个单位时间</p>
<p>如果</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>总线仲裁</p>
<ul>
<li>要解决的问题</li>
<li>方法和特点</li>
</ul>
<p>解决的是多个设备竞争使用总线的管理问题</p>
<p>集中仲裁和分布仲裁</p>
<p>集中式多采用CPU为仲裁器，可以实现计数器式查询，链式查询，独立查询三种方式</p>
<p>分布式仲裁的仲裁器为各个参与的主设备，实现所谓”比大小”的仲裁方式，最终获胜的主设备获得总线的使用权</p>
<p>总线的通信控制解决的问题是什么，大致方式</p>
<p>目的 解决主设备和从设备的协调调度配合问题</p>
<p>同步数据输入/输出</p>
<p>异步数据输入/输出</p>
<p>半同步通信方式    </p>
<p>请自行查阅资料，说明程序查询方式的工作过程。</p>
<p>CPU启动外设工作后，不断地读取外设的状态信息进行测试，查询外设是否准备就绪，如果准备号，则可以进行数据传送；否则，CPU继续读取外设的状态信息进行查询准备，直到外设准备好</p>
<p>请自行查阅资料，说明程序中断方式的工作过程。</p>
<p>当主机启动外设后，无需等待查询，而是继续执行原来的程序，外设在做好输入输出准备时，向主机发出中断请求，主机接到请求后就暂时中止原来执行的程序，转去执行中断服务程序对外部请求进行处理，在中断处理完毕后返回原来的程序继续执行</p>
<p>请自行查阅资料，说明DMA的工作过程。</p>
<p>1外设可通过DMA控制器向CPU发出DMA请求;</p>
<p>2CPU响应DMA请求，系统转变为DMA工作方式，并把总线控制权交给DMA控制器；</p>
<p>3由DMA控制器faculty存储器地址，并决定传送数据块的长度</p>
<p>4 执行DMA传送</p>
<p>5DMA操作结束，并把总线控制权交还CPU</p>
<p>请自行查阅资料，试比较程序查询、程序中断、DMA三种I/O方式的区别。</p>
<p>CPU需要根据外设的工作状态来决定何时进行数据传送，它要求CPU随时对结构状态进行查询，如果接口尚未准备好，CPU需要等待，并进行查询，只有接口准备好，CPU才进行数据的输入输出。它的的特点是简单，只需少量硬件，主要编制程序执行为主</p>
<p>程序中断方式: CPU在执行的程序的过程中，出现某些突然时间待处理，CPU</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/049bff7024af510580dff9b7f3bc8a4d.png" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>流出</th>
<th>执行</th>
<th>写结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIV.D F4,F2,F0</td>
<td>1</td>
<td>2-21</td>
<td>22</td>
</tr>
<tr>
<td>SD.D F4,0x05(R1)</td>
<td>2</td>
<td>3-4</td>
<td>23</td>
</tr>
<tr>
<td>ADD.D F10,F8,F0</td>
<td>3</td>
<td>4-7</td>
<td>8</td>
</tr>
<tr>
<td>LD.D F6,0x08(R2)</td>
<td>4</td>
<td>24-25</td>
<td>26</td>
</tr>
<tr>
<td>SUB.D F0,F2,F6</td>
<td>5</td>
<td>27-30</td>
<td>31</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>最终状态</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引</th>
<th>R1</th>
<th>R2</th>
<th>F0</th>
<th>F2</th>
<th>F4</th>
<th>F6</th>
<th>F8</th>
<th>F10</th>
<th>#0xC3</th>
<th>#0xC8</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值</td>
<td>oxC3</td>
<td>oxC0</td>
<td>0B-(0B/05)</td>
<td>0x0B</td>
<td>OB/05</td>
<td>0B/05</td>
<td>05+03</td>
<td>05+03</td>
<td>0x04</td>
<td>0B/05</td>
</tr>
</tbody>
</table>
</div>
<p>4.18</p>
<p>备注：标识用二进制，不命中率用分数。</p>
<p><img src="https://p.ananas.chaoxing.com/star3/origin/6252809c23aab9be73671204dcf31880.png" alt="img"></p>
<p>主存11位， cache 5位  指令2位</p>
<p>每块3位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识</th>
<th>索引</th>
<th>位移</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>OK 00000 1 00000 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Tag      </span><br><span class="line">000001 00 000</span><br><span class="line">000001 00 100</span><br><span class="line">000001 01 000</span><br><span class="line">000001 01 100</span><br><span class="line">000001 10 000</span><br><span class="line">000001 10 100</span><br><span class="line">000001 11 000</span><br><span class="line">000001 11 100</span><br><span class="line">000010 00 000</span><br></pre></td></tr></table></figure>
<p>N1 + 2 2 2 2 1   2 2 2 2 1</p>
<p>N2 + 1 1 1 1 1   1 0 0 0 1 </p>
<p>N1= 90</p>
<p>N2= 23</p>
<p>23/113</p>
<p>000010</p>
<p>000001</p>
<p>000001</p>
<p>000001</p>
<p>9/14</p>
<p>90次</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/计算机系统结构/" rel="tag"># 计算机系统结构</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/02/25/MCS/" rel="next" title="微机系统">
                  <i class="fa fa-chevron-left"></i> 微机系统
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/03/22/leetcode_mysql/" rel="prev" title="MySQL笔记">
                  MySQL笔记 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机系统结构的基本概念"><span class="nav-text">计算机系统结构的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引言"><span class="nav-text">引言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机系统结构的概念"><span class="nav-text">计算机系统结构的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#计算机系统的层次结构"><span class="nav-text">计算机系统的层次结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#计算机系统结构的定义"><span class="nav-text">计算机系统结构的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#计算机组成和计算机实现"><span class="nav-text">计算机组成和计算机实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机系统结构的分类"><span class="nav-text">计算机系统结构的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定量分析技术"><span class="nav-text">定量分析技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机系统结构的发展"><span class="nav-text">计算机系统结构的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#冯-cdot-诺伊曼结构"><span class="nav-text">冯 $\cdot$诺伊曼结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软件对系统结构的影响"><span class="nav-text">软件对系统结构的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#器件发展对系统结构的影响"><span class="nav-text">器件发展对系统结构的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#应用对系统结构的影响"><span class="nav-text">应用对系统结构的影响</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机系统结构中并行性的发展"><span class="nav-text">计算机系统结构中并行性的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#并行性的概念"><span class="nav-text">并行性的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提高并行性的技术途径"><span class="nav-text">提高并行性的技术途径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单机系统中并行性的发展"><span class="nav-text">单机系统中并行性的发展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多机系统中并行性的发展"><span class="nav-text">多机系统中并行性的发展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机指令集结构"><span class="nav-text">计算机指令集结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令集结构的分类"><span class="nav-text">指令集结构的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻址方式"><span class="nav-text">寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令集结构的功能设计"><span class="nav-text">指令集结构的功能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CISC-指令集结构的功能设计"><span class="nav-text">CISC 指令集结构的功能设计</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#面向目标程序增强功能"><span class="nav-text">面向目标程序增强功能</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#面向高级语言的优化来改进指令集"><span class="nav-text">面向高级语言的优化来改进指令集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#面向操作系统的优化实现改进指令集"><span class="nav-text">面向操作系统的优化实现改进指令集</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RISC-指令集的功能设计"><span class="nav-text">RISC 指令集的功能设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指令控制"><span class="nav-text">指令控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数的类型和大小"><span class="nav-text">操作数的类型和大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令格式的设计"><span class="nav-text">指令格式的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MIPS指令集结构"><span class="nav-text">MIPS指令集结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线技术"><span class="nav-text">流水线技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流水线"><span class="nav-text">流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线的分类"><span class="nav-text">流水线的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#单功能流水线和多功能流水线"><span class="nav-text">单功能流水线和多功能流水线</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#静态流水线与动态流水线"><span class="nav-text">静态流水线与动态流水线</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#部件级，处理机级及处理机间流水线"><span class="nav-text">部件级，处理机级及处理机间流水线</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#线性流水线与非线性流水线"><span class="nav-text">线性流水线与非线性流水线</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#顺序流水线与乱序流数线"><span class="nav-text">顺序流水线与乱序流数线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流水线性能指标"><span class="nav-text">流水线性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#吞吐率"><span class="nav-text">吞吐率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加速比"><span class="nav-text">加速比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#效率"><span class="nav-text">效率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#例子"><span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流水线的相关与冲突"><span class="nav-text">流水线的相关与冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个经典的5段流水线"><span class="nav-text">一个经典的5段流水线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相关与流水线冲突"><span class="nav-text">相关与流水线冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#相关"><span class="nav-text">相关</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#流水线冲突"><span class="nav-text">流水线冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流水线的实现"><span class="nav-text">流水线的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向量处理机"><span class="nav-text">*向量处理机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令级并行"><span class="nav-text">指令级并行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令级并行-1"><span class="nav-text">指令级并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令的动态调度"><span class="nav-text">指令的动态调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态调度的基本思想"><span class="nav-text">动态调度的基本思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tomasulo-算法"><span class="nav-text">Tomasulo 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Tomasulo的基本结构"><span class="nav-text">Tomasulo的基本结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tomasulo算法的基本执行步骤"><span class="nav-text">Tomasulo算法的基本执行步骤</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tomasulo算法详细解"><span class="nav-text">Tomasulo算法详细解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分支预测技术"><span class="nav-text">动态分支预测技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#采用分支历史表-BHT"><span class="nav-text">采用分支历史表(BHT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#采用分支目标缓冲器BTB"><span class="nav-text">采用分支目标缓冲器BTB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于硬件的前瞻预测"><span class="nav-text">基于硬件的前瞻预测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法详述"><span class="nav-text">算法详述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储系统"><span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储系统的层次结构"><span class="nav-text">存储系统的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#存储系统的性能参数"><span class="nav-text">存储系统的性能参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三级存储系统"><span class="nav-text">三级存储系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存储层次的4个问题"><span class="nav-text">存储层次的4个问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache"><span class="nav-text">Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本结构和原理"><span class="nav-text">基本结构和原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#映像规则"><span class="nav-text">映像规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找算法"><span class="nav-text">查找算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#替换算法"><span class="nav-text">替换算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写策略"><span class="nav-text">写策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作过程"><span class="nav-text">工作过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache的性能分析"><span class="nav-text">Cache的性能分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#降低Cache不命中率"><span class="nav-text">降低Cache不命中率</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#三种类型的不命中"><span class="nav-text">三种类型的不命中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增加Cache块大小"><span class="nav-text">增加Cache块大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增加Cache的容量"><span class="nav-text">增加Cache的容量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提高相联度"><span class="nav-text">提高相联度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#伪相联Cache"><span class="nav-text">伪相联Cache</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#减少Cache不命中开销"><span class="nav-text">减少Cache不命中开销</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#采用两级Cache"><span class="nav-text">采用两级Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#让读不命中优先于写"><span class="nav-text">让读不命中优先于写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写缓冲合并"><span class="nav-text">写缓冲合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求字处理技术"><span class="nav-text">请求字处理技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非阻塞Cache技术"><span class="nav-text">非阻塞Cache技术</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#减少命中时间"><span class="nav-text">减少命中时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#容量小，结构简单的Cache"><span class="nav-text">容量小，结构简单的Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟Cache"><span class="nav-text">虚拟Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache访问流水化"><span class="nav-text">Cache访问流水化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#踪迹Cache"><span class="nav-text">踪迹Cache</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行主存系统"><span class="nav-text">并行主存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单体多字存储器"><span class="nav-text">单体多字存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多体交叉存储器"><span class="nav-text">多体交叉存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#避免存储体冲突"><span class="nav-text">避免存储体冲突</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟存储器"><span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本概率"><span class="nav-text">基本概率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速地址转换技术"><span class="nav-text">快速地址转换技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入-输出系统"><span class="nav-text">输入/输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入-输出系统的性能"><span class="nav-text">输入/输出系统的性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入-输出系统的可靠性，可用性和可信性"><span class="nav-text">输入/输出系统的可靠性，可用性和可信性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#廉价磁盘冗余阵列"><span class="nav-text">廉价磁盘冗余阵列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线"><span class="nav-text">总线</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#总线的设计"><span class="nav-text">总线的设计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道处理机"><span class="nav-text">通道处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通道的作用和功能"><span class="nav-text">通道的作用和功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道的工作过程"><span class="nav-text">通道的工作过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道的种类"><span class="nav-text">通道的种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道种的数据传送过程与流量分析"><span class="nav-text">通道种的数据传送过程与流量分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题目"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#习题"><span class="nav-text">习题</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="endacsd">
  <p class="site-author-name" itemprop="name">endacsd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://makisevon.net" title="https://makisevon.net" rel="noopener" target="_blank">JJ</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="http://blog.sagiri-photo.com" title="http://blog.sagiri-photo.com" rel="noopener" target="_blank">SAGIRI</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://zhongmz.github.io" title="https://zhongmz.github.io" rel="noopener" target="_blank">zs</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.kaaass.net" title="https://blog.kaaass.net" rel="noopener" target="_blank">gs</a>
        </li>
      
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">endacsd</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  
<!DOCTYPE html>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<title></title>	
	<!-- require APlayer -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
	<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
	<!-- require MetingJS -->
	<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script>
	</head>
	<body>

<meting-js server="netease" type="song" id="33737052" fixed="true" volume="0.005" autoplay="true" loop="all" preload="auto" list-folded="ture" list-max-height="500px" lrc-type="1">
</meting-js>

	<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
